[{"title":"Python just for me","date":"2018-01-10T07:49:18.000Z","path":"2018/01/10/myPython/","text":"Python Python 3 Python基础Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。 数据类型和变量数据类型整数浮点数字符串","tags":[{"name":"Python","slug":"Python","permalink":"http://wenbo.fun/tags/Python/"}]},{"title":"分支限界---批处理作业调度","date":"2017-12-31T07:56:44.000Z","path":"2017/12/31/sf012/","text":"批处理作业调度问题描述 计算机算法设计与分析(第四版)，王晓东 n 个作业的集合: $$J={J1,J2,…,Jn}$$ 第 i 个作业需要机器 j 的处理时间: $$ t_{ij}$$ 已安排作业集合: $$M⊆{1,2…,n}$$ 所有作业在机器2完成时间和（包括等待时间）: $$f=\\sum_{i=1}^n{F_{2i}}$$ 以某个节点为根的子树中所含叶节点的完成时间和可表示为:$$f=\\sum_{i \\in M} F_{2i} + \\sum_{i \\notin M} F_{2i} $$ 实例: 排列树: 设 |M|=r , p_k 是第k个安排的作业,相应的作业调度为: $${p_k,k=1,2,……n}$$其中。如果从节点E到叶节点L的路上，每一个作业p_k在机器1上完成处理后都能立即在机器2上开始处理，即从p_r+1开始，机器1没有空闲时间,则对于该叶节点有:$$\\sum_{i \\notin M}F_{2i} = \\sum_{k=r+1}^n[F_{1p_r}+(n-k+1)t_{1p_k}+t_{2p_k}]$$ 式子中(n-k+1),因为是求的是作业完成时间和，所以，后续的(n-k+1)个作业完成时间和都得算上 如果不是按照上面安排，则s1会增加，从而有:$$\\sum_{i \\notin M}F_{2i} \\ge S_1 $$类似，从p_r+1开始，让机器2没有空闲时间:$$\\sum_{i \\notin M}F_{2i} = \\sum_{k=r+1}^n[ \\max(F_{2p_r},F_{1p_r} + \\min\\limits_{i \\notin M} t_{1i}) + (n-k+1)t_{2p_k}] = S_2$$从而得到下界(限界函数):$$f \\ge \\sum_{i \\notin M}F_{2i} + \\max \\{S_1,S_2\\}$$ java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/** * 批处理作业调度问题--优先队列式分支限界法 **/import java.util.Collections;import java.util.LinkedList;public class BBFlow &#123; public int n;//作业数 public int bestc;//最小完成时间和 public int [][]m;//个作业所需的处理时间数组 public int [][]b;//个作业所需的处理时间排序数组 public int[][] a;//数组m和b的对应关系数组 public int[] bestx;//最优解 public boolean[][] y;//工作数组 public BBFlow(int n,int[][] m)&#123; this.n=n; bestc=10000; this.m=m; b=new int[n][2]; a=new int[n][2]; bestx=new int[n]; y=new boolean[n][2]; &#125; public void swap(int[][] b,int i,int j,int k,int t)&#123; int temp=b[i][j]; b[i][j]=b[k][t]; b[k][t]=temp; &#125; public void swap(int[] x,int i,int j)&#123; int temp=x[i]; x[i]=x[j]; x[j]=temp; &#125;/*** 对个作业在机器1和2上所需时间排序*/ public void sort()&#123; int[] c=new int[n]; for(int j=0;j&lt;2;j++)&#123; for(int i=0;i&lt;n;i++)&#123; b[i][j]=m[i][j]; c[i]=i; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int k=n-1;k&gt;i;k--)&#123; if(b[k][j]&lt;b[k-1][j])&#123; swap(b,k,j,k-1,j); swap(c,k,k-1); &#125; &#125; &#125; for(int i=0;i&lt;n;i++) a[c[i]][j]=i; &#125; &#125; /** * 计算完成时间和下界 * @param enode * @param f * @return */ public int bound(Nodes enode,int[] f)&#123; for(int k=0;k&lt;n;k++)&#123; for(int j=0;j&lt;2;j++)&#123; y[k][j]=false; &#125; &#125; for(int k=0;k&lt;enode.s;k++)&#123; for(int j=0;j&lt;2;j++)&#123; y[a[enode.x[k]][j]][j]=true; &#125; &#125; f[1]=enode.f[1]+m[enode.x[enode.s]][0]; f[2]=((f[1]&gt;enode.f[2])?f[1]:enode.f[2])+m[enode.x[enode.s]][1]; int sf2=enode.sf2+f[2]; int s1=0; int s2=0; int k1=n-enode.s; int k2=n-enode.s; int f3=f[2]; //计算s1的值 for(int j=0;j&lt;n;j++)&#123; if(!y[j][0])&#123; k1--; if(k1==n-enode.s-1) f3=(f[2]&gt;f[1]+b[j][0])?f[2]:f[1]+b[j][0]; s1+=f[1]+k1*b[j][0]; &#125; &#125; //计算s2的值 for(int j=0;j&lt;n;j++)&#123; if(!y[j][1])&#123; k2--; s1+=b[j][1]; s2+=f3+k2*b[j][1]; &#125; &#125; //返回完成时间和下界 return sf2+((s1&gt;s2)?s1:s2); &#125; /** * 优先队列式分支限界法解批处理作业调度问题 * @param nn * @return */ public int bbFlow(int nn)&#123; n=nn; sort();//对个作业在机器1和2上所需时间排序 LinkedList&lt;Nodes&gt; heap=new LinkedList&lt;Nodes&gt;(); Nodes enode =new Nodes(n); //搜索排列空间树 do&#123; if(enode.s==n)&#123; //叶节点 if(enode.sf2&lt;bestc)&#123; bestc=enode.sf2; for(int i=0;i&lt;n;i++)&#123; bestx[i]=enode.x[i]; &#125; &#125; &#125;else&#123; //产生当前扩展结点的儿子结点 for(int i=enode.s;i&lt;n;i++)&#123; swap(enode.x,enode.s,i); int[] f=new int[3]; int bb=bound(enode,f); if(bb&lt;bestc)&#123; //子树可能含有最优解 //结点插入最小堆 Nodes node=new Nodes(enode,f,bb,n); heap.add(node); Collections.sort(heap); &#125; swap(enode.x,enode.s,i); &#125;//完成结点扩展 &#125; //取下一个扩展结点 enode=heap.poll(); &#125;while(enode!=null&amp;&amp;enode.s&lt;=n); return bestc; &#125; public static void main(String[] args) &#123; int n=3; int[][] m=&#123;&#123;2,1&#125;,&#123;3,1&#125;,&#123;2,3&#125;&#125;;//m的下标从0开始 BBFlow f=new BBFlow(n,m); f.bbFlow(n); System.out.println(\"最优批处理作业调度顺序为：\"); for(int i=0;i&lt;n;i++) System.out.print((f.bestx[i]+1)+\" \"); System.out.println(); System.out.println(\"最优调度所需的最短时间为：\"+f.bestc); &#125;&#125;class Nodes implements Comparable&#123; int s;//已安排作业数 int sf2;//当前机器2上的完成时间和 int bb;//当前完成时间和下界 int[] f;//f[1]机器1上最后完成时间，f[2]机器2上最后完成时间 int[] x;//当前作业调度 public Nodes(int n)&#123; //最小堆结点初始化 x=new int[n]; for(int i=0;i&lt;n;i++) x[i]=i; s=0; f=new int[3]; f[1]=0; f[2]=0; sf2=0; bb=0; &#125; public Nodes(Nodes e,int[] ef,int ebb,int n)&#123; //最小堆新结点 x=new int[n]; for(int i=0;i&lt;n;i++) x[i]=e.x[i]; f=ef; sf2=e.sf2+f[2]; bb=ebb; s=e.s+1; &#125; @Override public int compareTo(Object o) &#123; int xbb=((Nodes) o).bb; if(bb&lt;xbb) return -1; if(bb==xbb) return 0; return 1; &#125;&#125;/*运行结果：最优批处理作业调度顺序为：1 3 2最优调度所需的最短时间为：18*/","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"分支限界---布线问题","date":"2017-12-30T11:07:34.000Z","path":"2017/12/30/sf011/","text":"分支限界与回溯回溯法盲目搜索从根节点出发，按照状态空间树的结构，向下搜索它的所有儿子结点，对不满足约束条件的儿子结点，把它丢弃；对满足约束条件的结点，继续相似搜索它的所有儿子结点。该搜索过程一直进行，当搜索到一个满足约束条件的叶结点时，就得到了一个可行解；或者所有的儿子结点都不满足约束条件时，该结点就被丢弃，向上回溯到它的父亲结点。 分支限界法启发式搜索 在结点估算沿着它的各儿子结点搜索时，目标函数可能取得的“界” 把儿子结点和目标函数可能取得的“界”，保存在优先队列或堆中 从队列或堆中选取“界”最大或最小的结点向下搜索，直到叶子结点 若叶子结点的目标函数的值，是结点表中的最大值或最小值，则沿叶子结点到根结点的路径所确定的解，就是问题的最优解，由该叶子结点所确定的目标函数的值，就是解这个问题所得到的最大值或最小值 界 对最小值问题，称为下界，意思是向下搜索所可能取得的值最小不会小于这些下界。 对最大值问题，称为上界，意思是向下搜索所可能取得的值最大不会大于这些上界。 子集树与排列树子集树问题可以理解为在一个集合中选取一个满足某种条件的子集。我们对待选集合任意排序，然后顺次对其中的元素给出两种决策： 左: 将当前元素选入集合右: 放弃当前元素 整个解空间所呈现出的是一棵二叉树。算法复杂度为$$O(2 ^ n)$$ E.g. 0-1背包问题 排列树问题可以理解为在一个集合的排列中寻找一个符合要求的排列。我们采用这样的策略： 每一次的决策都是从当前集合选出一个元素，将其余元素放入下次决策。当集合为空，我们生成了一个排列。 算法复杂度$$O(n!)$$ E.g. 旅行商问题 回溯与分支限界的比较 搜索模型的不同 回溯使用递归栈作为辅助，按既定顺序逐条搜索每一条从树根到叶子的路径。 分支限界法使用优先级队列或队列作为辅助，寻找“最优”路径。 目标不同 回溯法更为通用，而分支限界法用于寻找最优解 时间效率(搜索最优解问题) 回溯法搜索的时间正比于搜索解空间的大小 分支限界法的时间敏感于最优解所在位置，当最优解偏树根，则时间相对于搜索整个解空间树非常少。 空间效率 回溯法的空间消耗与解空间（最大）树高有关 分支限界法的空间消耗一般表现出广度优先搜索的特点，与解空间的宽度有关。 一般树高远小于树宽,所以可以认为分支限界法是回溯法的一种空间换时间的技术 布线问题问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度扩展节点: $$O(1)$$每个方格此为活结点进入队列最多一次，总结点数:$$O(mn)$$构造最短距离(L是最短路径的长度):$$O(L)$$ java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import java.util.LinkedList; import java.util.Scanner; /** * 布线问题 * @author Lican * */ public class WireRouter &#123; public int[][] grid;//方格阵列;=0表示该方格运行布线；=1表示被封锁，不允许布线 public int size;//方格阵列大小 public int pathLen;//最短线路长度 public LinkedList&lt;Position&gt; q;//扩展结点队列，用list存储 public Position start;//起始位置 public Position finish;//终点 public Position[] path;//最短路径 public WireRouter(int[][] grid,int size,Position start,Position finish)&#123; this.grid=grid; this.size=size; this.start=start; this.finish=finish; &#125; /** * 方格所在位置 * @author Lican * */ public static class Position&#123; public int row;//行 public int col;//列 public Position(int r ,int c)&#123; row=r; col=c; &#125; &#125; /** *计算从起始位置start到目标位置finish的最短布线路径 * @return 找到最短布线路径则返回true，否则返回false */ public boolean findPath()&#123; if(start.row==finish.row&amp;&amp;start.col==finish.col)&#123;//start==finish,最短路径为0 pathLen=0; return true; &#125; //初始化相对位移 Position[] offset=new Position[4]; offset[0]=new Position(0,1);//右 offset[1]=new Position(1,0);//下 offset[2]=new Position(0,-1);//左 offset[3]=new Position(-1,0);//上 //设置方格阵列“围墙”，方便处理方格边界的情况 for(int i=0;i&lt;=size+1;i++)&#123; grid[0][i]=grid[size+1][i]=1;//顶部和底部 grid[i][0]=grid[i][size+1]=1;//左边和右边 &#125; Position here=new Position(start.row,start.col); grid[start.row][start.col]=2;//数字0,1表示方格的开放或封锁所以，表示距离时，让所有距离都加2；起始位置的距离为0+2=2 int numOfNbrs=4;//相邻方格数 //以下为标记可达的方格位置 q=new LinkedList&lt;Position&gt;(); Position nbr=new Position(0,0); do&#123; //标记可达的相邻方格(每个方格有四个相邻方格) for(int i=0;i&lt;numOfNbrs;i++)&#123; nbr.row=here.row+offset[i].row; nbr.col=here.col+offset[i].col; if(grid[nbr.row][nbr.col]==0)&#123;//该方格未被标记，且该方格允许布线 grid[nbr.row][nbr.col]=grid[here.row][here.col]+1; if(nbr.row==finish.row&amp;&amp;nbr.col==finish.col) break; q.add(new Position(nbr.row,nbr.col)); &#125; &#125; //检测是否到达目标位置finish if(nbr.row==finish.row&amp;&amp;nbr.col==finish.col) break; if(q.isEmpty()) return false; here=q.poll(); &#125;while(true); //构造最短布线路径 pathLen=grid[finish.row][finish.col]-2; path=new Position[pathLen]; //从目标位置finish开始向起始位置回溯 here=finish; for(int j=pathLen-1;j&gt;=0;j--)&#123; path[j]=here; //找前驱位置 for(int i=0;i&lt;numOfNbrs;i++)&#123; nbr.row=here.row+offset[i].row; nbr.col=here.col+offset[i].col; if(grid[nbr.row][nbr.col]==j+2) break; &#125; here=new Position(nbr.row,nbr.col); &#125; System.out.println(\"最短路线为：\"); for(int j=0;j&lt;pathLen-1;j++)&#123; System.out.println(\"点\"+(j+1)+\"位置: 行-\"+path[j].row+\" 列-\"+path[j].col); &#125; System.out.println(\"布线长度为：\"+pathLen); return true; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(\"请输入方格阵列大小：\"); String s1=sc.nextLine(); Integer size=Integer.parseInt(s1); System.out.println(\"请输入起始点的行和列，用空格隔开：\"); String s2=sc.nextLine(); String[] s3=s2.split(\" \"); int startRow=Integer.parseInt(s3[0]); int startCol=Integer.parseInt(s3[1]); Position start=new Position(startRow,startCol); System.out.println(\"请输入结束点的行和列，用空格隔开：\"); String s4=sc.nextLine(); String[] s5=s4.split(\" \"); int finishRow=Integer.parseInt(s5[0]); int finishCol=Integer.parseInt(s5[1]); Position finish=new Position(finishRow,finishCol); int[][] grid=new int[size+2][size+2]; System.out.println(\"请输入方格阵列：\"); for(int i=1;i&lt;=size;i++)&#123; String str=sc.nextLine(); String[] strs=str.split(\" \"); for(int j=0;j&lt;strs.length;j++)&#123; grid[i][j+1]=Integer.parseInt(strs[j]); &#125; &#125; WireRouter w=new WireRouter(grid,size,start,finish); w.findPath(); &#125; &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"回溯法---0-1背包问题","date":"2017-12-30T09:04:17.000Z","path":"2017/12/30/sf010/","text":"0-1背包问题问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度计算上界时间:$$O(n)$$ 最坏情况有:$$O(2^n)$$个右儿子节点需计算上界。所以回溯算法Backtrack所需时间:$$O(n2^n)$$ java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 0-1背包问题--回溯法 * */ public class Knapsack &#123; public static class Element implements Comparable&#123; int id;//物品编号 double d; public Element(int id,double d)&#123; this.id=id; this.d=d; &#125; @Override public int compareTo(Object x) &#123; double xd=((Element)x).d;//递减顺序排列 if(d&lt;xd) return -1; if(d==xd) return 0; return 1; &#125; &#125; double c;//背包容量 int n;//物品数 double[] w;//物品重量数组 double[] p;//物品价值数组 double cw;//当前重量 double cp;//当前价值 double bestp;//最优价值 int[] x;//当前装入背包顺序 int[] bestx;//最优装入背包顺序 Element[] q;//q为单位重量价值数组 public double knapsack(double[] pp,double[] ww,double cc)&#123; //初始化 c=cc; n=pp.length-1; cw=0; cp=0; bestp=0; x=new int[n+1]; bestx=new int[n+1]; //q为单位重量价值数组 q=new Element[n+1]; for(int i=0;i&lt;=n;i++)&#123; q[i]=new Element(i,pp[i]/ww[i]); &#125; //将个物品依单位重量价值从大到小排列 java.util.Arrays.sort(q); p=new double[n+1]; w=new double[n+1]; for(int i=1;i&lt;=n;i++)&#123; p[i]=pp[q[i].id]; w[i]=ww[q[i].id]; &#125; backtrack(1); return bestp; &#125; public void backtrack(int i)&#123; if(i&gt;n)&#123;//到达叶子节点 bestp=cp; for(int j=1;j&lt;=n;j++)&#123;//保存最优值对应的包的编号 bestx[j]=x[j]; &#125; return; &#125; if(cw+w[i]&lt;=c)&#123;//左子树 x[i]=1; cw+=w[i]; cp+=p[i]; backtrack(i+1); cw-=w[i];//恢复现场 cp-=p[i]; &#125; if(bound(i+1)&gt;bestp)&#123; x[i]=0; backtrack(i+1); &#125; &#125; public double bound(int i)&#123;//上界函数 double cleft=c-cw; double bound=cp; while(i&lt;=n&amp;&amp;w[i]&lt;=cleft)&#123; cleft-=w[i]; bound+=p[i]; i++; &#125; if(i&lt;=n)&#123; bound+=p[i]*cleft/w[i]; &#125; return bound; &#125; public static void main(String[] args) &#123; double[] weight=&#123;0,71,34,82,23,1,88,12,57,10,68,5,33,37,69,98,24,26,83,16,26,18,43,52,71,22,65,68,8,40,40,24,72,16,34,10,19,28,13,34,98,29,31,79,33,60,74,44,56,54,17&#125;; double[] price=&#123;0,26,59,30,19,66,85,94,8,3,44,5,1,41,82,76,1,12,81,73,32,74,54,62,41,19,10,65,53,56,53,70,66,58,22,72,33,96,88,68,45,44,61,78,78,6,66,11,59,83,48&#125;; double cc=300; //double[] weight=&#123;0,7,3,4,5&#125;; //double[] price=&#123;0,42,12,40,25&#125;; //double cc=10; Knapsack k=new Knapsack(); double best=k.knapsack(price,weight,cc); System.out.println(\"最优值：\"+best); System.out.println(\"选中的物品编号分别是：\"); for(int i=1;i&lt;k.bestx.length;i++)&#123; if(k.bestx[i]==1)&#123; System.out.print(k.q[i].id+\" \"); &#125; &#125; &#125; &#125; /* 输出结果：最优值：1063.0选中的物品编号分别是：5 7 35 38 28 19 21 33 37 31 50 44 39 42 2 11 */","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"回溯法---符号三角形","date":"2017-12-30T05:07:21.000Z","path":"2017/12/30/sf009/","text":"回溯法 问题解空间 深度优先遍历 深度搜索至任意一个节点，若包括问题解，继续按深度优先策略搜索;如果不包含问题解，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯。 减枝函数 符号三角形问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度计算可行性约束(符号个数)需要时间:$$O(n)$$最坏情况(n个符号排列)有:$$O(2^n)$$个节点需要计算可行性约束，故回溯算法 Backtrack 所需计算时间: $$O(n2^n)$$ java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Triangles &#123; private int n;// 第一行符号个数 private int half;// n*(n+1)/4 private int count;//当前\"+\"号个数 private int[][] p;//符号三角形矩阵 private long sum;//已找到符号三角形数 private void Backtrack(int t) &#123; if((count&gt;half)||(t*(t-1)/2-count&gt;half)) return;// 控制\"+\"\"-\"个数相等 if(t&gt;n) sum++; else &#123; for (int i = 0; i &lt; 2; i++) &#123;// 1 为\"+\" , 0为\"-\" p[1][t] = i; count += i; for (int j = 2; j &lt;= t; j++) &#123; p[j][t-j+1] = p[j-1][t-j+1]^p[j-1][t-j+2]; count += p[j][t-j+1]; &#125; Backtrack(t+1); for (int j = 2; j &lt;= t; j++) &#123; count -= p[j][t-j+1]; &#125; count -= i; &#125; &#125; &#125; private static long Compute(int n) &#123; Triangles X = new Triangles(); X.n = n; X.count = 0; X.half = n*(n+1)/2; if (X.half%2 == 1)return 0;// 符号数为奇数 X.half = X.half/2; X.sum = 0; int[][] p = new int[n+1][n+1]; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) &#123; p[i][j] = 0; &#125; X.p = p; X.Backtrack(1); return X.sum; &#125; public static void main(String[] args) &#123; int m = 3; long n = Compute(m); System.out.println(\"第一行符号数 n=\"+m+\"时，有\"+n+\"个符号三角形\"); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"贪心算法---最小生成树","date":"2017-12-30T03:17:39.000Z","path":"2017/12/30/sf008/","text":"最小生成树问题描述 计算机算法设计与分析(第四版)，王晓东 最小生成树性质 假设 N = (V,{ E })是一个连通网，U 是顶点集 V 的一个非空子集。若(u , v)是一条具有最小权值(代价)的边，其中u∈U， v∈V - U，则必存在一棵包含边(u，v)的最小生成树。 反证: 假设网N的任何一棵最小生成树都不包含(u，v)。设T是连通网上的一棵最小生成树，当将边(u，v)加入到T中时，由生成树的定义，T中必存在一条包含(u，v)的回路。另一方面，由于T是生成树，则在T上必存在另一条边(u’，v’)，其中u’∈U，v’∈V - U，且u和u’之间，v和v’之间均有路径相通。删去边(u’，v’)，便可消除上述回路，同时得到另一棵生成树T’。因为(u，v)的代价不高于(u’，v’)，则T’的代价亦不高于T，T’是包含(u，v)的一棵最小生成树，和假设矛盾。 时间复杂度 略 Prim(普里姆算法) 算法选取满足条件 i∈S，j∈V-S，且 c[i][j] 最小的边，将顶点 j 添加到 S 中。这个过程一直进行到 S=V 时为止。在这个过程中选取到的所有边恰好构成G的一棵最小生成树T。 java 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MinSpanTree &#123; public static void Prim(int n, int[][] c) &#123; int[] lowcost= new int[n]; int[] closest= new int[n]; boolean[] s= new boolean[n]; s[1] = true; // 初始化lowcost[i](到顶点i最小代价)，closest[i](i的连接点) for (int i = 2; i &lt; n; i++) &#123; lowcost[i] = c[1][i]; closest[i] = 1; s[i] = false; &#125; for (int i = 1; i &lt; n-1; i++) &#123; int min = Integer.MAX_VALUE; int j = 1; for (int k = 2; k &lt; n; k++) &#123; if ((lowcost[k] &lt; min)&amp;&amp;(!s[k])) &#123; min = lowcost[k];j=k; &#125; &#125; System.out.println(j); s[j] = true; //将第j个顶点纳入S for (int k = 2; k &lt; n; k++) &#123; if ((c[j][k] &lt; lowcost[k])&amp;&amp;(!s[k])) &#123; lowcost[k] = c[j][k];closest[k] = j; &#125; &#125; System.out.println(closest[j]+\"&lt;--&gt;\"+j); &#125; &#125; public static void main(String[] args) &#123; int MAX_WEIGHT =Integer.MAX_VALUE; // matri[i][j] = a 表示顶点i到j的权值为a int[][] matrix = &#123; &#123;MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT&#125;, &#123;MAX_WEIGHT,0,6,1,5,MAX_WEIGHT,MAX_WEIGHT&#125;, &#123;MAX_WEIGHT,6,0,5,MAX_WEIGHT,3,MAX_WEIGHT&#125;, &#123;MAX_WEIGHT,1,5,0,5,6,4&#125;, &#123;MAX_WEIGHT,5,MAX_WEIGHT,5,0,MAX_WEIGHT,2&#125;, &#123;MAX_WEIGHT,MAX_WEIGHT,3,6,MAX_WEIGHT,0,6&#125;, &#123;MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,4,2,6,0&#125; &#125;; int n = matrix.length; Prim(n, matrix); &#125;&#125; Kruskal 算法首先将G的n个顶点看成n个孤立的连通分支。将所有的边按权从小到大排序。然后从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接2个不同的连通分支：当查看到第k条边(v,w)时，如果端点v和w分别是当前2个不同的连通分支T1和T2中的顶点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；如果端点v和w在当前的同一个连通分支中，就直接再查看第k+1条边。这个过程一直进行到只剩下一个连通分支时为止。","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"贪心算法---单源最短路径","date":"2017-12-30T02:34:34.000Z","path":"2017/12/30/sf007/","text":"单源最短路径问题描述 计算机算法设计与分析(第四版)，王晓东 给定一个带权有向图 G=（V,E），其中每条边的权是一个非负实数。另外，还给定V中的一个顶点，称为源。现在要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。 其基本思想是，设置顶点集合S并不断地作贪心选择来扩充这个集合。每一次加入S 的点都是距离S之外最短的点。 贪心选择性质该算法所作出的贪心选择是从V-S中选择具有最短特殊路径的顶点u，从而确定从源S到u的最短路径长度为dist[u]. 反证: dist[u]表示从已挑选集合源S到u的最短路径长度，假设有一点x不属于S使得从源经过x再到u的距离比dist[u]更短。d(v,x)表示从S中源点v到x的距离，显然:$$dist[x] &lt;= d(v,x)$$由假设可得:$$d(v,x) + d(x,u) = d(v,u) &lt; dist[u] $$因为$$d(x,u) &gt;= 0$$推出$$dist[x]&lt;dist[u]$$这就表明x就是距离源外最短的点，也就是原来的u，而不是假设的 中间点，故此为矛盾，证毕。 最优子结构性质java 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Dijkstra &#123; static float maxint = Float.MAX_VALUE-1000; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stubfloat c[ ][ ] =&#123;&#123;maxint,maxint,maxint,maxint,maxint,maxint&#125;,&#123;maxint,maxint,10,maxint,30,100&#125;,&#123;maxint,10,maxint,50,maxint,maxint&#125;,&#123;maxint,maxint,50,maxint,20,10&#125;,&#123;maxint,maxint,maxint,20,maxint,60&#125;,&#123;maxint,100,maxint,10,60,maxint&#125;&#125;; float dist[ ] = new float [7]; int prev[ ] = new int [7]; int n = 5; int v = 1; dijkstra(n, v, dist, prev, c); &#125; /** * @param n n个顶点 * @param v 顶点v为源点 * @param dist dist[i]记录源点到i顶点最短特殊路径长度 * @param prev prev[i]记录源点到i顶点最短路径上，i的前一个顶点 * @param c c[i][j]表示边(i,j)的权 */ public static void dijkstra(int n, int v, float dist[ ],int prev[ ],float c[ ][ ]) &#123; boolean[ ] s = new boolean[n + 1]; for (int i = 1; i &lt;= n ; i++) &#123; dist[i] = c[v][i]; s[i] = false; if(dist[i] == maxint) prev[i] = 0; else prev[i] = v; &#125; dist[v] = 0; s[v] = true; for (int i = 1; i &lt; n; i++) &#123; float temp = maxint; int u =v; for (int j = 1; j &lt; n; j++) &#123; if ( (!s[j]) &amp;&amp; (dist[j] &lt; temp) ) &#123; u = j; temp = dist[j]; &#125; &#125; s[u] = true; for (int j = 1; j &lt;= n; j++) &#123; if ((!s[j]) &amp;&amp; (c[u][j] &lt; maxint) ) &#123; float newdist = dist[u] + c[u][j]; if(newdist &lt; dist[j] ) &#123; dist[j] = newdist; prev[j] = u; &#125; &#125; &#125; &#125; for(int i=2;i&lt;=5;i++)&#123; System.out.println(\"prev[\"+i+\"] = \"+prev[i]); &#125; for(int i=2;i&lt;=5;i++)&#123; System.out.println(\"dist[\"+i+\"] = \"+dist[i]); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"贪心算法---活动安排问题","date":"2017-12-28T11:46:02.000Z","path":"2017/12/28/sf006/","text":"活动安排问题问题描述 计算机算法设计与分析(第四版)，王晓东 贪心选择性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择. 动态规划: 每步所做的选择往往依赖于相关子问题的解。只有解除子问题的解才能做出选择。_自底向上_ 贪心算法: 仅在当前状态下做出最好选择，即局部最优选择。_自顶向下_ 对于一个具体问题，要确定它是否具有 贪心选择性质,必须证明每一步所作的贪心选择最终导致问题的整体最优解。 活动安排问题贪的是 活动最早完成时间 ，直观上为未安排活动留下更多时间。 最优子结构性质若集合 A 是所有活动集 E 中包含活动 1 的一个最优解，则集合 A’ = A - {1} 也是对于 E’ (以活动1结束时间为起始时间)的一个最优解。 反证: 若能找到 E’ 的一个解 B’ ,它包含比 A’ 更多的活动，则将活动1加入到 B’ 将产生 E 的一个解 B ，它包含比 A 更多的活动，这与 A 的最优性矛盾。 时间复杂度算法排序起始时间: $$O(nlogn)$$算法安排活动只需: $$\\theta(n)$$ java 代码1234567891011121314151617181920212223242526272829303132333435public class GreedySelector &#123; /** * * @param s 活动开始时间 * @param f 活动结束时间 * @param A 是否选择活动 * @return 已选择活动数 */ public static int greedyselector(int[] s,int[] f,boolean[] A) &#123; int n = s.length - 1; int count = 1; A[1] = true; int j = 1; System.out.print(\"start:(1)\"+ s[1] + \"-&gt;\" + f[1] + \"-&gt;\"); for(int i=2;i&lt;=n;i++) &#123; if (s[i] &gt;= f[j]) &#123; A[i] = true; j=i;count++; System.out.print(\"(\"+i+\")\"+ s[i] + \"-&gt;\" + f[i] + \"-&gt;\"); &#125;else &#123; A[i] = false; &#125; &#125; System.out.print(\"end\\n\"); return count; &#125; public static void main(String[] args) &#123; int s[]=&#123;1,3,0,5,3,5,6,8,8,2,12&#125;; int f[]=&#123;4,5,6,7,8,9,10,11,12,13,14&#125;; boolean [] a=new boolean[11]; int c = greedyselector(s, f, a); System.out.println(\"共有\"+c+\"个活动被安排。\"); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"动态规划---最长公共子序列","date":"2017-12-26T11:33:31.000Z","path":"2017/12/26/sf005/","text":"最长公共子序列问题描述 计算机算法设计与分析(第四版)，王晓东 最优子结构性质设序列 X={x1,x2,…,xm} 和 Y={y1,y2,…,yn} 的最长公共子序列为 Z={z1,z2,…,zk} ，则 若xm=yn，则zk=xm=yn，且Z k-1是xm-1和yn-1的最长公共子序列。 若xm≠yn且zk≠xm，则Z是xm-1和Y的最长公共子序列。 若xm≠yn且zk≠yn，则Z是X和yn-1的最长公共子序列。 两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有 最优子结构性质。 子问题递归结构用c[i][j]记录序列Xi和Yj的最长公共子序列的长度。其中，$$ Xi={x1,x2,…,xi};Yj={y1,y2,…,yj}$$当 i=0 或 j=0 时，空序列是 Xi 和 Yj 的最长公共子序列。故此时C[i][j]=0。其他情况下，由最优子结构性质可建立递归关系如下: java 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package dtgh;public class LongestCommonSub &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str1 = \"ABCBDAB\"; String str2 = \"BDCABA\"; //计算lcs递归矩阵 int[][] re = longestCommonSubsequence(str1, str2); //打印矩阵 for (int i = 0; i &lt;= str1.length(); i++) &#123; for (int j = 0; j &lt;= str2.length(); j++) &#123; System.out.print(re[i][j] + \" \"); &#125; System.out.println(); &#125; System.out.println(); System.out.println(); //输出LCS print(re, str1, str2, str1.length(), str2.length()); &#125; // 假如返回两个字符串的最长公共子序列的长度 public static int[][] longestCommonSubsequence(String str1, String str2) &#123; int[][] matrix = new int[str1.length() + 1][str2.length() + 1];//建立二维矩阵 // 初始化边界条件 for (int i = 0; i &lt;= str1.length(); i++) &#123; matrix[i][0] = 0;//每行第一列置零 &#125; for (int j = 0; j &lt;= str2.length(); j++) &#123; matrix[0][j] = 0;//每列第一行置零 &#125; // 填充矩阵 for (int i = 1; i &lt;= str1.length(); i++) &#123; for (int j = 1; j &lt;= str2.length(); j++) &#123; if (str1.charAt(i - 1) == str2.charAt(j - 1)) &#123; matrix[i][j] = matrix[i - 1][j - 1] + 1; &#125; else &#123; matrix[i][j] = (matrix[i - 1][j] &gt;= matrix[i][j - 1] ? matrix[i - 1][j] : matrix[i][j - 1]); &#125; &#125; &#125; return matrix; &#125; //根据矩阵输出LCS public static void print(int[][] opt, String X, String Y, int i, int j) &#123; if (i == 0 || j == 0) &#123; return; &#125; if (X.charAt(i - 1) == Y.charAt(j - 1)) &#123; print(opt, X, Y, i - 1, j - 1); System.out.print(X.charAt(i - 1)); &#125; else if (opt[i - 1][j] &gt;= opt[i][j]) &#123; print(opt, X, Y, i - 1, j); &#125; else &#123; print(opt, X, Y, i, j - 1); &#125; &#125; &#125; python代码12345678910111213141516171819202122232425262728293031323334353637383940def lcs(a,b): lena=len(a) lenb=len(b) c=[[0 for i in range(lenb+1)] for j in range(lena+1)] flag=[[0 for i in range(lenb+1)] for j in range(lena+1)] for i in range(lena): for j in range(lenb): if a[i]==b[j]: c[i+1][j+1]=c[i][j]+1 flag[i+1][j+1]='ok' elif c[i+1][j]&gt;c[i][j+1]: c[i+1][j+1]=c[i+1][j] flag[i+1][j+1]='left' else: c[i+1][j+1]=c[i][j+1] flag[i+1][j+1]='up' return c,flag def printLcs(flag,a,i,j): if i==0 or j==0: return if flag[i][j]=='ok': printLcs(flag,a,i-1,j-1) print(a[i-1],end='') elif flag[i][j]=='left': printLcs(flag,a,i,j-1) else: printLcs(flag,a,i-1,j) a='ABCBDAB' b='BDCABA' c,flag=lcs(a,b) for i in c: print(i) print('') for j in flag: print(j) print('') printLcs(flag,a,len(a),len(b)) print('')","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"动态规划---矩阵连乘","date":"2017-12-23T14:08:08.000Z","path":"2017/12/23/sf004/","text":"矩阵连乘问题描述 计算机算法设计与分析(第四版)，王晓东 动态规划基本要素最优子结构 当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。 计算 A[1:n] 的最优次序，其所包含的矩阵子链 A[1:k] 和 A[k+1:n] 的次序也是最优的。即该问题具有 最优子结构性质。 反证法证明：如果有一个计算 A[1:k] 的次序需要的计算量更少，则用此次序替换原来计算 A[1:k] 次序，得到的计算 A[1:n] 的计算量将比按最优次序计算量更少，这与前提矛盾。计算最优值:因为n个元素对2求组合数最多为 n(n-1)/2，另外还有 n 个单矩阵的子问题,因此，不同子问题的个数最多只有: 重叠子问题 区别于分治法,动态规划可以解决有些问题用分治法计算存在的大量重复计算。 最优解递归关系将矩阵连乘积 $$ A_{i}A_{i-1}A_{i-2}A_{i-3}…. $$简记为 $$A[i:j],i≤j$$设计算 $$A[i:j]，1≤i≤j≤n$$ 所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n].则 m[i][j] 可递归定义为: 算法复杂度分析算法MatrixChain的主要计算量取决于算法中的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3)。因此算法的计算时间上界为O(n^3)。算法所占用的空间显然为O(n^2)。 java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MatrixMul &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub /** *p[i]的含义有两层指的是： *1. 第i个矩阵的列 *2. 第i+1个矩阵的行 **/ int []p = &#123;30,35,15,5,10,20,25&#125;; int len = p.length; int [][]m = new int [len+1][len+1];//记录连乘次数 int [][]s = new int [len+1][len+1];//记录最佳分割位置 MatrixChain(p,len,m,s); System.out.println(\"矩阵计算量最小次数矩阵m[i][j]:\"); PrintMatrixMul(m,p.length); System.out.println(\"相对于M矩阵的最优断开位置矩阵s[i][j]:\"); PrintMatrixMul(s,p.length); System.out.println(\"乘法的最优次序：\"); traceback(1,len-1,s); &#125; // 打印数组 private static void PrintMatrixMul(int[][] m,int n) &#123; for(int i = 1;i&lt;=n-1;i++)&#123; for(int j =1;j&lt;=n-1;j++)&#123; System.out.print(m[i][j]+\"\\t\"); if(j % (n-1) ==0)System.out.print(\"\\n\"); &#125; &#125; &#125; /** * * @param p 输入参数&#123;p0，p1，p2，...&#125; * @param n * @param m 最优值数组 * @param s 最优断开位置数组 */ public static void MatrixChain(int[] p, int n, int [][]m, int [][]s) &#123; for (int i = 1; i &lt;= n; i++) &#123;m[i][i] = 0;&#125;// 初始化单个矩阵连乘 for (int r = 2; r &lt;= n; r++) &#123; for (int i = 1; i &lt;= n-r; i++) &#123; int j = i+r-1; m[i][j] = m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j] = i; for (int k = i+1; k &lt; j; k++) &#123; int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if (t &lt; m[i][j]) &#123; m[i][j] = t;s[i][j] = k; &#125; &#125; &#125; &#125; &#125; /** * * @param i * @param j * @param s */ private static void traceback(int i, int j, int[][] s) &#123; if (i == j) &#123; System.out.print(\"A\"+i); &#125;else if(i+1 == j )&#123; System.out.print(\" (A\"+i+\" * \"+\" A\"+j+\") \"); &#125;else &#123; System.out.print(\" (\"); traceback(i, s[i][j], s); traceback(s[i][j]+1,j, s); System.out.print(\") \"); &#125; &#125;&#125; python代码12345678910111213141516171819202122232425262728293031323334353637class Matrix: def __init__(self, row_num=0, col_num=0, matrix=None): if matrix != None: self.row_num = len(matrix) self.col_num = len(matrix[0]) else: self.row_num = row_num self.col_num = col_num self.matrix = matrix def matrix_chain(matrixs): matrix_num = len(matrixs) count = [[0 for j in range(matrix_num)] for i in range(matrix_num)] flag = [[0 for j in range(matrix_num)] for i in range(matrix_num)] for r in range(1, matrix_num + 1): for i in range(matrix_num - r): j = i + interval count[i][j] = count[i][i] + count[i + 1][j] + matrixs[i].row_num * matrixs[i + 1].row_num * matrixs[j].col_num flag[i][j] = i for k in range(i + 1, j): temp = count[i][k] + count[k + 1][j] + matrixs[i].row_num * matrixs[k + 1].row_num * matrixs[j].col_num if temp &lt; count[i][j]: count[i][j] = temp flag[i][j] = k traceback(0, matrix_num - 1, flag) return count[0][matrix_num - 1] def traceback(i, j, flag): if i == j: return if j - i &gt; 1: print(str(i + 1) + '~' + str(j + 1), end=': ') print(str(i + 1) + \":\" + str(flag[i][j] + 1), end=',') print(str(flag[i][j] + 2) + \":\" + str(j + 1)) traceback(i, flag[i][j], flag) traceback(flag[i][j] + 1, j, flag) matrixs = [Matrix(30, 35), Matrix(35, 15), Matrix(15, 5), Matrix(5, 10), Matrix(10, 20), Matrix(20, 25)] result = matrix_chain(matrixs) print(result)","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"递归与分治---快速排序","date":"2017-12-22T11:33:07.000Z","path":"2017/12/22/sf003/","text":"快速排序问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度分析最坏情况:每次划分的基准刚好为中值。 $$T(n)=2*T(n/2)+n$$ 其平均算法复杂度为: $$O(nlogn)$$ java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.Random;public class QuickSort &#123; public static void main (String[] args) &#123; int[] array = &#123;6,7,4,5,2,3,1&#125;; int[] arr = QuickSort.Quicksort(array, 0, array.length-1); System.out.println(\"最终结果\"); for (int i : arr) &#123; System.out.print(i + \" \"); &#125; System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); System.out.println(\"随机选择策略：\"); int[] array2 = &#123;6,7,4,5,2,3,1&#125;; int[] arr2 = QuickSort.RandomizedQuicksort(array2, 0, array.length-1); System.out.println(\"最终结果\"); for (int i : arr2) &#123; System.out.print(i + \" \"); &#125; &#125; public static int Partition(int[] arr, int low, int high) &#123; int i = low,j = high+1; int base = arr[low];// 基准元素 while(true) &#123; while(arr[++i] &lt; base &amp;&amp; i &lt; high) &#123; System.out.println(\"从左往右找比\" + base + \"大的，左指针变动：--&gt;\" + i); &#125; while(arr[--j] &gt; base) &#123; System.out.println(\"从右往左找比\" + base + \"小的，右指针变动：--&gt;\" + j); &#125; if(i &gt;= j) break; Swap(arr, i, j); &#125; arr[low] = arr[j]; arr[j] = base; System.out.println(\"对调\" + arr[low] + \"与\" + arr[j] + \",得到\"); for (int k : arr) &#123; System.out.print(k + \" \"); &#125; System.out.println(); return j; &#125; private static int[] Quicksort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int division = Partition(arr, low, high); Quicksort (arr, low, division - 1); Quicksort (arr, division + 1 , high); &#125; return arr; &#125; public static void Swap(int[] array, int a, int b) &#123; if(a != b) &#123; int temp = array[a]; array[a] = array[b]; array[b] = temp; System.out.println(\"对调\" + array[a] + \"与\" + array[b] + \",得到\"); for (int i : array) &#123; System.out.print(i + \" \"); &#125; System.out.println(); &#125; &#125; private static int[] RandomizedQuicksort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int q = RandomizedPartition(arr, low, high); RandomizedQuicksort (arr, low, q - 1); RandomizedQuicksort (arr, q + 1 , high); &#125; return arr; &#125; public static int RandomizedPartition(int[] arr, int low, int high) &#123; Random random = new Random(System.currentTimeMillis()); int i = random.nextInt(high-low)+low; Swap(arr, i, low); return Partition(arr, low, high); &#125;&#125; python代码12345678910111213141516171819202122232425def QuickSort(arr,firstIndex,lastIndex): if firstIndex&lt;lastIndex: divIndex=Partition(arr,firstIndex,lastIndex) QuickSort(arr,firstIndex,divIndex) QuickSort(arr,divIndex+1,lastIndex) else: returndef Partition(arr,firstIndex,lastIndex): i=firstIndex-1 for j in range(firstIndex,lastIndex): if arr[j]&lt;=arr[lastIndex]: i=i+1 arr[i],arr[j]=arr[j],arr[i] arr[i+1],arr[lastIndex]=arr[lastIndex],arr[i+1] return iarr=[1,4,7,1,5,5,3,85,34,75,23,75,2,0]print(\"initial array:\\n\",arr)QuickSort(arr,0,len(arr)-1)print(\"result array:\\n\",arr)","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"递归与分治---合并排序","date":"2017-12-22T01:55:32.000Z","path":"2017/12/22/sf002/","text":"合并排序 (归并排序)问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度分析 java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MergeSort &#123; public static void main (String[] args) &#123; int[] array = &#123;1,3,4,6,2,7,5&#125;; int[] arr = new MergeSort().sort(array); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]); &#125; &#125; public int[] sort(int[] arrs)&#123; if(arrs.length &lt; 2)&#123; return arrs; &#125; int middle = arrs.length % 2 == 0 ? arrs.length / 2 : (arrs.length - 1) / 2; int[] left = Arrays.copyOfRange(arrs, 0, middle); int[] right = Arrays.copyOfRange(arrs, middle, arrs.length); int[] lres = sort(left); // 递归 int[] rres = sort(right); return merge(lres, rres); &#125; private int[] merge(int[] lres, int[] rres) &#123; // 合并左右数组 int[] res = new int[lres.length + rres.length]; int l = 0; int r = 0; int c = 0; while(l &lt; lres.length &amp;&amp; r &lt; rres.length)&#123; if(lres[l] &lt; rres[r])&#123; res[c++] = lres[l++]; &#125; else &#123; res[c++] = rres[r++]; &#125; &#125; if(l == lres.length)&#123; while(r &lt; rres.length)&#123; res[c++] = rres[r++]; &#125; return res; &#125; if(r == rres.length)&#123; while(l &lt; lres.length)&#123; res[c++] = lres[l++]; &#125; return res; &#125; return res; &#125;&#125; python 代码一般方法123456789101112131415161718192021222324252627282930def merge_sort(seq): if len(seq)== 1: return seq else: middle = len(seq)//2 left = merge_sort(seq[:middle]) right = merge_sort(seq[middle:]) i = 0 // left j = 0 // right k = 0 // all while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: seq[k] = left[i] i += 1 k += 1 else: seq[k] = right[j] j += 1 k += 1 // remain of left or right remain = left if i&lt;j else right r = i if remain == left else j while r&lt;len(remain): seq[k] = remain[r] r += 1 k += 1 return seq pop123456789101112131415161718def merge_sort_w(seq): if len(seq) &lt;= 1: return seq def merge(left,right): merged = [] while left and right: merged.append(left.pop(0) if left[0] &lt;= right[0] else right.pop(0)) // remain while left: merged.append(left.pop(0)) while right: merged.append(right.pop(0)) return merged middle = int(len(seq) / 2) left = merge_sort_w(seq[:middle]) right = merge_sort_w(seq[middle:]) return merge(left,right) heapq12345678910from heapq import mergedef merge_sort_h(seq): if len(seq) &lt;= 1: return seq else: middle = len(seq)//2 left = merge_sort_h(seq[:middle]) right = merge_sort_h(seq[middle:]) return list(merge(left, right)) # heapq.merge","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"递归与分治---棋盘覆盖","date":"2017-12-20T01:38:17.000Z","path":"2017/12/20/sf001/","text":"棋盘覆盖问题描述 计算机算法设计与分析(第四版)，王晓东 在一个2^k * 2^k个方格组成的棋盘中,若有一个方格与其他方格不同,则称该方格为一特殊方格,且称该棋盘为一个特殊棋盘。显然特殊方格在棋盘上出现的位置有4^k种情形. 因而对任何k ≥ 0,有 4^k 种不同的特殊棋盘。下图所示的特殊棋盘为 k=2 时 16 个特殊棋盘中的一个。 在棋盘覆盖问题中，要用下图中 4 中不同形态的 L 型骨牌覆盖一个给定的特殊棋牌上除特殊方格以外的所有方格，且任何 2 个 L 型骨牌不得重叠覆盖。易知，在任何一个 2^k * 2^k 的棋盘中，用到的 L 型骨牌个数恰为 (4^k-1)/3 。 求解棋盘问题，可利用分治的策略。当 k&gt;0 时，将 2^k 2^k 棋盘分割为 4 个 2^(k-1) 2^(k-1) 子棋盘，如下图所示。 特殊方格必位于 4 个较小子棋盘之一中，其余 3 个子棋盘中无特殊方格。用一个 L 型骨牌覆盖这 3 个较小的棋盘的 汇合处 ，如图所示，将这 3 个无特殊方格的子棋盘转化为 特殊棋盘，从而将原问题化为 4 个较小规模的棋盘覆盖问题。递归的使用 这种分割，直至棋盘简化为 1x1 棋盘。 时间复杂度分析 java 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package dgfz;import java.awt.Color;import java.awt.Container;import java.awt.Graphics;import javax.swing.JFrame;public class qpfg &#123; public static void main (String[] args) &#123; new DrawPanel(); &#125;&#125;class DrawPanel extends JFrame &#123; //设定特殊棋子位置坐标 private int dx = 2; private int dy = 1; //棋盘大小 private int dsize = 8; // 2^k * 2^k //小方块边长 private static final int c = 50; // 窗口大小 int a = dsize*c+50; // L型骨牌号 private static int tile = 0; private Graphics jp; /** * DrawPanel构造方法 */ public DrawPanel() &#123; Container p = getContentPane(); setBounds(100, 100, a+100, a+100); setVisible(true); p.setBackground(Color.WHITE); setLayout(null); setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try &#123; // 等待时间 Thread.sleep(500); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; jp = this.getGraphics(); //绘制 painPanel(jp); &#125;public void painPanel(Graphics g) &#123; /** * 画棋盘 * */ try &#123; //画格子 g.setColor(Color.RED); g.drawRect(c, c, dsize*c, dsize*c); for (int i = 1; i &lt; dsize; i++) &#123; g.drawLine(c + (i * c), c, c + (i * c), a); g.drawLine(c,c + (i * c), a, c + (i * c)); &#125; //设定特殊棋子位置 g.setColor(Color.BLACK); g.fillRect(c*dx+5, c*dy+5, c-10, c-10); g.setColor(Color.RED); Thread.sleep(500); chess(1, 1, dx, dy, dsize, g); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public void chess(int tr, int tc, int dr, int dc, int size, Graphics g) &#123; /* * 棋盘分割 * tr,tc:棋盘左上角行列号 * dr,dc:特殊方格行列号 * size： size = 8，就是棋盘大小8 x 8 * */ try &#123; if (size == 1) return ; String tt = String.valueOf(tile++); int s = size / 2; //左上 if(dr &lt; tr + s &amp;&amp; dc &lt; tc + s) // 特殊方格在此棋盘中 chess(tr, tc, dr, dc, s, g); else &#123; // 特殊方格不在此棋盘中，用L型骨牌号 tt 填入右下角 g.drawString(tt, (tr + s - 1)*c+c/2, (tc + s - 1)*c+c/2); System.out.println((tr+s-1)+\",\"+(tc + s - 1)+\"---&gt;\"+tt); chess(tr, tc, tr+s-1, tc+s -1, s, g); &#125; //右上 if(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) chess(tr, tc + s, dr, dc, s, g); else &#123; g.drawString(tt, (tr + s - 1)*c+c/2, (tc + s)*c+c/2); System.out.println((tr+s-1)+\",\"+(tc + s)+\"---&gt;\"+tt); chess(tr, tc + s, tr+s-1, tc+s , s, g); &#125; //左下 if(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) chess(tr + s, tc, dr, dc, s, g); else &#123; g.drawString(tt, (tr + s )*c+c/2, (tc + s - 1)*c+c/2); System.out.println((tr+s)+\",\"+(tc + s - 1)+\"---&gt;\"+tt); chess(tr +s , tc, tr+s, tc+s -1, s, g); &#125; //右下 if(dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) chess(tr + s, tc + s, dr, dc, s, g); else &#123; g.drawString(tt, (tr + s)*c+c/2, (tc + s)*c+c/2); System.out.println((tr+s)+\",\"+(tc + s)+\"---&gt;\"+tt); chess(tr + s, tc + s, tr+s, tc+s , s, g); &#125; Thread.sleep (500 ) ; &#125; catch (InterruptedException ie)&#123; &#125; &#125;&#125; python 代码 12345678910111213141516171819202122232425262728293031323334353637383940// tr左上角行号，tc左上角列号。dr特殊方格行号，dc特殊方格列号def chessboard(board, size, tr, tc, dr, dc): if size &lt;= 1: return global tile tile += 1 current_tile = tile size //= 2 if dr &lt; tr + size and dc &lt; tc + size: chessboard(board, size, tr, tc, dr, dc) else: board[tr + size - 1][tc + size - 1] = current_tile chessboard(board, size, tr, tc, tr + size - 1, tc + size - 1) if dr &gt;= tr + size and dc &lt; tc + size: chessboard(board, size, tr + size, tc, dr, dc) else: board[tr + size][tc + size - 1] = current_tile chessboard(board, size, tr + size, tc, tr + size, tc + size - 1) if dr &lt; tr + size and dc &gt;= tc + size: chessboard(board, size, tr, tc + size, dr, dc) else: board[tr + size - 1][tc + size] = current_tile chessboard(board, size, tr, tc + size, tr + size - 1, tc + size) if dr &gt;= tr + size and dc &gt;= tc + size: chessboard(board, size, tr + size, tc + size, dr, dc) else: board[tr + size][tc + size] = current_tile chessboard(board, size, tr + size, tc + size, tr + size, tc + size)tile = 0chessboard_size = 4board = [[0 for x in range(chessboard_size)] for y in range(chessboard_size)]chessboard(board, chessboard_size, 0, 0, 1, 0)board = [[row[i] for row in board] for i in range(len(board[0]))]for lst in board: print(lst)","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"Sklearn中Kmeans与可视化","date":"2017-12-13T14:02:42.000Z","path":"2017/12/13/kmeans-sklearn/","text":"KmeansK-means算法: 两个缺点: Inertia makes the assumption that clusters are convex and isotropic, which is not always the case. It responds poorly to elongated clusters, or manifolds with irregular shapes. Inertia is not a normalized metric: we just know that lower values are better and zero is optimal. But in very high-dimensional spaces, Euclidean distances tend to become inflated (this is an instance of the so-called “curse of dimensionality”). Running a dimensionality reduction algorithm such as PCA prior to k-means clustering can alleviate this problem and speed up the computations. 聚类算法：from sklearn.cluster import KMeans def init(self, n_clusters=8, init=’k-means++’, n_init=10, max_iter=300,tol=1e-4,precompute_distances=’auto’,verbose=0, random_state=None, copy_x=True, n_jobs=1): km_cluster = KMeans(n_clusters=num_clusters, max_iter=300, n_init=40,init=’k-means++’,n_jobs=-1) n_clusters : 分成的簇数也是要生成的质心数 init: 初始化质心,默认值：采用 k-means++ n_init: 设置选择质心种子次数，默认为10次。返回质心最好的一次结果（好是指计算时长短） max_ite: 每次迭代的最大次数 tol: 容忍的最小误差，当误差小于tol就会退出迭代（算法中会依赖数据本身）,默认值：le-4(0.0001) precompute_distances: 这个参数会在空间和时间之间做权衡，如果是True 会把整个距离矩阵都放到内存中，auto 会默认在数据样本大于featurs*samples 的数量大于12e6 的时候False, 默认值：“auto” verbose:是否输出详细信息,默认值：False random_state: 随机生成器的种子 ，和初始化中心有关, 默认值：None copy_x:bool 在scikit-learn 很多接口中都会有这个参数的，就是是否对输入数据继续copy 操作，以便不修改用户的输入数据。这个要理解Python 的内存机制才会比较清楚。(待研究) 默认值：True n_jobs: 使用进程的数量，与电脑的CPU有关.默认值: 1 Kmeans++ 能够解决kmeans对噪声敏感的问题。kmeans寻找种子点的时候计算该类中所有样本的平均值，如果该类中具有较为明显的离群点，会造成种子点与期望偏差过大。例如，A(1,1),B(2,2),C(3,3),D(1000,1000)，显然D点会拉动种子点向其偏移。这样，在下一轮迭代时，将大量不该属于该类的样本点错误的划入该类。为了解决这个问题，kmedoids方法采取新的种子点选取方式: 1）只从样本点中选；2）选取标准能够提高聚类效果，例如最小化J函数，或者自定义其他的代价函数。但是，kmedoids方法提高了聚类的复杂度。 k-means++算法选择初始seeds的基本思想就是：初始的聚类中心之间的相互距离要尽可能的远。 wiki上对该算法的描述如下: 从输入的数据点集合中随机选择一个点作为第一个聚类中心 对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x) 选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大 重复2和3直到k个聚类中心被选出来 利用这k个初始的聚类中心来运行标准的k-means算法 code import 123456from sklearn.cluster import KMeansfrom sklearn.externals import joblibimport numpy as npfrom time import timeimport matplotlib.pyplot as pltfrom sklearn.manifold import TSNE 12345678910111213141516171819// load data print('Load data...') dataSet = [] fileIn = open('./result1.txt')// result1 是一个10986x34行，一列的数据 for line in fileIn.readlines(): a = line.strip().split(' ') dataSet.append(float(a[0])) B = np.reshape(dataSet,(10986,34))// 聚类数 num_clusters = 26 km_cluster = KMeans(n_clusters=num_clusters, max_iter=300, n_init=40, \\ init='k-means++',n_jobs=-1)// 聚类label结果 result = km_cluster.fit_predict(B) print (\"Predicting result: \", result) np.savetxt(\"a.txt\",result) 降维(二向箔？)将高维的聚类数据在降到二维上显示，使用 sklearn 的 TSNE. code1： 12345678910111213141516171819202122232425262728// B 是34维 x 10986XX = B// result 是所聚的labelYY = result// 可视化def plot_embedding(X, title=None): x_min, x_max = np.min(X, 0), np.max(X, 0) X = (X - x_min) / (x_max - x_min) plt.figure() ax = plt.subplot(111) for i in range(X.shape[0]): plt.text(X[i, 0], X[i, 1], str(YY[i]), color=plt.cm.Set1(YY[i] / 10.), fontdict=&#123;'weight': 'bold', 'size': 9&#125;) plt.xticks([]), plt.yticks([]) if title is not None: plt.title(title)// t-SNE embedding of the digits datasetprint(\"Computing t-SNE embedding\")tsne = TSNE(n_components=2, init='pca', random_state=0)t0 = time()X_tsne = tsne.fit_transform(B)plot_embedding(X_tsne,\"t-SNE embedding of the digits (time %.2fs)\" % (time() - t0))// plot_embedding_3d(X_tsne,\"t-SNE embedding of the digits (time %.2fs)\" % (time() - t0))plt.show() 效果图：(分类太多看不清楚233333) code 2 :( 网路上 ) 12345678910111213141516...from sklearn.manifold import TSNEtsne = TSNE()tsne.fit_transform(data_zs) // 进行数据降维tsne = pd.DataFrame(tsne.embedding_, index = data_zs.index) //转换数据格式import matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] //用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False //用来正常显示负号//不同类别用不同颜色和样式绘图d = tsne[r[u'聚类类别'] == 0]plt.plot(d[0], d[1], 'r.')d = tsne[r[u'聚类类别'] == 1]plt.plot(d[0], d[1], 'go')d = tsne[r[u'聚类类别'] == 2]plt.plot(d[0], d[1], 'b*')plt.show()","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wenbo.fun/tags/机器学习/"},{"name":"聚类","slug":"聚类","permalink":"http://wenbo.fun/tags/聚类/"},{"name":"Kmeans","slug":"Kmeans","permalink":"http://wenbo.fun/tags/Kmeans/"}]},{"title":"keras","date":"2017-12-13T03:54:48.000Z","path":"2017/12/13/keras/","text":"Keras 中文文档","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wenbo.fun/tags/机器学习/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://wenbo.fun/tags/Deep-Learning/"},{"name":"Keras","slug":"Keras","permalink":"http://wenbo.fun/tags/Keras/"}]},{"title":"人脸识别04：识别是不是我","date":"2017-12-10T13:12:46.000Z","path":"2017/12/10/is-my-face/","text":"代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.........sess = tf.Session()saver.restore(sess, tf.train.latest_checkpoint('.'))def is_my_face(image): res = sess.run(predict, feed_dict=&#123;x: [image/255.0], keep_prob_5:1.0, keep_prob_75: 1.0&#125;) if res[0] == 1: return True else: return False// 使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()cam = cv2.VideoCapture(0)// Set FONT_HERSHEY_SIMPLEX// font = cv2.FONT_HERSHEY_SIMPLEXwhile True: _, img = cam.read() gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) dets = detector(gray_image, 1) if not len(dets): //print('Can`t get face.') cv2.imshow('img', img) key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0) for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 face = img[x1:y1,x2:y2] // 调整图片的尺寸 face = cv2.resize(face, (size,size)) print('Is this my face? %s' % is_my_face(face)) cv2.rectangle(img, (x2,x1),(y2,y1), (255,0,0),3) //cv2.rectangle(im, (x-22,y-90), (x+w+22, y-22), (0,255,0), -1) //cv2.putText(img, 'right', (x2,x1-40), font, 2, (255,255,255), 3) cv2.imshow('image',img) key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0)sess.close()","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"CNN","slug":"CNN","permalink":"http://wenbo.fun/tags/CNN/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://wenbo.fun/tags/TensorFlow/"}]},{"title":"人脸识别03：Tensorflow+CNN训练","date":"2017-12-08T14:05:35.000Z","path":"2017/12/08/cnn-train-faces/","text":"使用Tensorflow+CNN训练神经网络 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import tensorflow as tfimport cv2import numpy as npimport osimport randomimport sysfrom sklearn.model_selection import train_test_splitmy_faces_path = './my_faces'other_faces_path = './other_faces'size = 64imgs = []labs = []def getPaddingSize(img): h, w, _ = img.shape top, bottom, left, right = (0,0,0,0) longest = max(h, w) if w &lt; longest: tmp = longest - w //表示整除符号 left = tmp // 2 right = tmp - left elif h &lt; longest: tmp = longest - h top = tmp // 2 bottom = tmp - top else: pass return top, bottom, left, rightdef readData(path , h=size, w=size): for filename in os.listdir(path): if filename.endswith('.jpg'): filename = path + '/' + filename img = cv2.imread(filename) top,bottom,left,right = getPaddingSize(img) // 将图片放大，,给源图像增加边界 img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0,0,0]) img = cv2.resize(img, (h, w)) imgs.append(img) labs.append(path)readData(my_faces_path)readData(other_faces_path)// 将图片数据与标签转换成数组imgs = np.array(imgs)labs = np.array([[0,1] if lab == my_faces_path else [1,0] for lab in labs])// 随机划分测试集与训练集 5%的测试集train_x,test_x,train_y,test_y = train_test_split(imgs, labs, test_size=0.05, random_state=random.randint(0,100))// 参数：图片数据的总数，图片的高、宽、通道// shape[0]行数train_x = train_x.reshape(train_x.shape[0], size, size, 3)test_x = test_x.reshape(test_x.shape[0], size, size, 3)// 将数据转换成小于1的数train_x = train_x.astype('float32')/255.0test_x = test_x.astype('float32')/255.0print('train size:%s, test size:%s' % (len(train_x), len(test_x)))// 图片块，每次取100张图片batch_size = 100num_batch = len(train_x) // batch_size// 保存数据 特定格式x = tf.placeholder(tf.float32, [None, size, size, 3])y_ = tf.placeholder(tf.float32, [None, 2])keep_prob_5 = tf.placeholder(tf.float32)keep_prob_75 = tf.placeholder(tf.float32)def weightVariable(shape): // 标准差 0.01 的正态分布 init = tf.random_normal(shape, stddev=0.01) return tf.Variable(init)def biasVariable(shape): init = tf.random_normal(shape) return tf.Variable(init)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1,1,1,1], padding='SAME')def maxPool(x): return tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')def dropout(x, keep): return tf.nn.dropout(x, keep)def cnnLayer(): // 第一层 W1 = weightVariable([3,3,3,32]) // 卷积核大小(3,3)， 输入通道(3)， 输出通道(32) b1 = biasVariable([32]) // 卷积 // 作用是计算激活函数relu，即max(features, 0)。 conv1 = tf.nn.relu(conv2d(x, W1) + b1) // 池化 pool1 = maxPool(conv1) // 减少过拟合，随机让某些权重不更新 drop1 = dropout(pool1, keep_prob_5) // 第二层 W2 = weightVariable([3,3,32,64]) b2 = biasVariable([64]) conv2 = tf.nn.relu(conv2d(drop1, W2) + b2) pool2 = maxPool(conv2) drop2 = dropout(pool2, keep_prob_5) // 第三层 W3 = weightVariable([3,3,64,64]) b3 = biasVariable([64]) conv3 = tf.nn.relu(conv2d(drop2, W3) + b3) pool3 = maxPool(conv3) drop3 = dropout(pool3, keep_prob_5) // 全连接层 Wf = weightVariable([8*16*32, 512]) bf = biasVariable([512]) drop3_flat = tf.reshape(drop3, [-1, 8*16*32]) dense = tf.nn.relu(tf.matmul(drop3_flat, Wf) + bf) dropf = dropout(dense, keep_prob_75) // 输出层 Wout = weightVariable([512,2]) bout = weightVariable([2]) //out = tf.matmul(dropf, Wout) + bout out = tf.add(tf.matmul(dropf, Wout), bout) return outdef cnnTrain(): out = cnnLayer() cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=y_)) train_step = tf.train.AdamOptimizer(0.01).minimize(cross_entropy) // 比较标签是否相等，再求的所有数的平均值，tf.cast(强制转换类型) accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, 1), tf.argmax(y_, 1)), tf.float32)) // 将loss与accuracy保存以供tensorboard使用 tf.summary.scalar('loss', cross_entropy) tf.summary.scalar('accuracy', accuracy) merged_summary_op = tf.summary.merge_all() // 数据保存器的初始化 saver = tf.train.Saver() with tf.Session() as sess: sess.run(tf.global_variables_initializer()) summary_writer = tf.summary.FileWriter('./tmp', graph=tf.get_default_graph()) for n in range(10): // 每次取128(batch_size)张图片 for i in range(num_batch): batch_x = train_x[i*batch_size : (i+1)*batch_size] batch_y = train_y[i*batch_size : (i+1)*batch_size] // 开始训练数据，同时训练三个变量，返回三个数据 _,loss,summary = sess.run([train_step, cross_entropy, merged_summary_op], feed_dict=&#123;x:batch_x,y_:batch_y, keep_prob_5:0.5,keep_prob_75:0.75&#125;) summary_writer.add_summary(summary, n*num_batch+i) // 打印损失 print(n*num_batch+i, loss) if (n*num_batch+i) % 100 == 0: // 获取测试数据的准确率 acc = accuracy.eval(&#123;x:test_x, y_:test_y, keep_prob_5:1.0, keep_prob_75:1.0&#125;) print(n*num_batch+i, acc) // 准确率大于0.98时保存并退出 if acc &gt; 0.98 and n &gt; 2: saver.save(sess, './train_faces.model', global_step=n*num_batch+i) sys.exit(0) print('accuracy less 0.98, exited!')cnnTrain() 相关函数tf.nn.dropout1tf.nn.dropout(x, keep) dropout(x, keep_prob, noise_shape=None, seed=None, name=None) x: 一个Tensor。keep_prob: 一个 Python 的 float 类型。表示元素是否放电的概率。noise_shape: 一个一维的Tensor，数据类型是int32。代表元素是否独立的标志。seed: 一个Python的整数类型。设置随机种子。name: （可选）为这个操作取一个名字。 tf.nn.conv2d1return tf.nn.conv2d(x, W, strides=[1,1,1,1], padding=&apos;SAME&apos;) tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None) 除去name参数用以指定该操作的name，与方法有关的一共五个参数： 第一个参数input：指需要做卷积的输入图像，它要求是一个Tensor，具有[batch, in_height, in_width, in_channels]这样的shape，具体含义是[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个4维的Tensor，要求类型为float32和float64其中之一。 第二个参数filter：相当于CNN中的卷积核，它要求是一个Tensor，具有[filter_height, filter_width, in_channels, out_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同，有一个地方需要注意，第三维in_channels，就是参数input的第四维 第三个参数strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4 第四个参数padding：string类型的量，只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式，表示是否要保留不完全卷积的部分。 第五个参数：use_cudnn_on_gpu:bool类型，是否使用cudnn加速，默认为true 结果返回一个Tensor，这个输出，就是我们常说的feature map，shape仍然是[batch, height, width, channels]这种形式。 tf.nn.max_pool1tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding=&apos;SAME&apos;) tf.nn.max_pool(value, ksize, strides, padding, name=None) 参数是四个，和卷积很类似：第一个参数value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape第二个参数ksize：池化窗口的大小，取一个四维向量，一般是[1, height, width, 1]第三个参数strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]第四个参数padding：和卷积类似，可以取’VALID’ 或者’SAME’ 返回一个Tensor，类型不变，shape仍然是[batch, height, width, channels]这种形式 train_test_splitCross Validation 基本思想是把在某种意义下将原始数据(dataset)进行分组,一部分做为训练集(train set),另一部分做为验证集(validation set or test set),首先用训练集对分类器进行训练,再利用验证集来测试训练得到的模型(model),以此来做为评价分类器的性能指标。 sklearn.model_selection.train_test_split随机划分训练集和测试集官网文档：http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html#sklearn.model_selection.train_test_split train_test_split是交叉验证中常用的函数，功能是从样本中随机的按比例选取train data和testdata. 形式为： X_train,X_test, y_train, y_test = cross_validation.train_test_split(train_data,train_target,test_size=0.4, random_state=0) 参数解释： train_data：所要划分的样本特征集 train_target：所要划分的样本标签 test_size：样本占比，如果是整数的话就是样本的数量（0.4就是测试集占40%） random_state：是随机数的种子。 随机数种子： 其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则： 1.种子不同，产生不同的随机数 2.种子相同，即使实例不同也产生相同的随机数。","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"CNN","slug":"CNN","permalink":"http://wenbo.fun/tags/CNN/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://wenbo.fun/tags/TensorFlow/"}]},{"title":"人脸识别02：dlib批量识别其他图片集","date":"2017-12-08T13:52:15.000Z","path":"2017/12/08/set-other-people/","text":"dlib批量识别其他图片集 处理方式跟上一个程序一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import sysimport osimport cv2import dlibinput_dir = './input_img'output_dir = './other_faces'size = 64if not os.path.exists(output_dir): os.makedirs(output_dir)//使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()index = 1for (path, dirnames, filenames) in os.walk(input_dir): for filename in filenames: if filename.endswith('.jpg'): print('Being processed picture %s' % index) img_path = path+'/'+filename //从文件读取图片 img = cv2.imread(img_path) //转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) // 使用detector进行人脸检测 dets为返回的结果 dets = detector(gray_img, 1) \"\"\" 使用enumerate 函数遍历序列中的元素以及它们的下标 下标i即为人脸序号 left：人脸左边距离图片左边界的距离 ；right：人脸右边距离图片左边界的距离 top：人脸上边距离图片上边界的距离 ；bottom：人脸下边距离图片上边界的距离 \"\"\" for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 // img[y:y+h,x:x+w] face = img[x1:y1,x2:y2] // 调整图片的尺寸 face = cv2.resize(face, (size,size)) cv2.imshow('image',face) // 保存图片 cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0)","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"Dlib","slug":"Dlib","permalink":"http://wenbo.fun/tags/Dlib/"}]},{"title":"人脸识别01：dlib获取图片集","date":"2017-12-08T03:09:34.000Z","path":"2017/12/08/face-recognition-dlib/","text":"Dlib Dlib 是一个跨平台的C++公共库，除了线程支持，网络支持，提供测试以及大量工具等等优点，Dlib还是一个强大的机器学习的C++库，包含了许多机器学习常用的算法，而且它还不依赖其他库。 程序详解 get_my_faces_dlib.pyDlib 自带的 frontal_face_detector 特征提取器结合了现在经典的 梯度方向直方图 (Histogram of Oriented Gradients feature) Wikipedia, 参考 线性分类器 (linear classifier) Wikipedia,线性分类器与非线性分类器 图像金字塔 an image pyramid Wikipedia, 参考 滑窗检测 sliding window detection . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import cv2import dlibimport osimport sysimport randomoutput_dir = './my_faces'size = 64if not os.path.exists(output_dir): os.makedirs(output_dir)// 改变图片的亮度与对比度def relight(img, light=1, bias=0): w = img.shape[1] h = img.shape[0] //image = [] for i in range(0,w): for j in range(0,h): for c in range(3): tmp = int(img[j,i,c]*light + bias) if tmp &gt; 255: tmp = 255 elif tmp &lt; 0: tmp = 0 img[j,i,c] = tmp return img//使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()//打开摄像头 参数为输入流，可以为摄像头或视频文件camera = cv2.VideoCapture(0)index = 1while True: if (index &lt;= 1000): print('Being processed picture %s' % index) // 从摄像头读帧 success, img = camera.read() // 转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) // 使用detector进行人脸检测 \"\"\" The 1 in the second argument indicates that we should upsample the image 1 time. This will make everything bigger and allow us to detect more faces. \"\"\" dets = detector(gray_img, 1) print(\"Number of faces detected: &#123;&#125;\".format(len(dets))) for i, d in enumerate(dets): print(\"Detection &#123;&#125;: Left: &#123;&#125; Top: &#123;&#125; Right: &#123;&#125; Bottom: &#123;&#125;\".format( i, d.left(), d.top(), d.right(), d.bottom())) x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 // 裁剪 face = img[x1:y1,x2:y2] // 调整图片的对比度与亮度， 对比度与亮度值都取随机数，这样能增加样本的多样性 face = relight(face, random.uniform(0.5, 1.5), random.randint(-50, 50)) face = cv2.resize(face, (size,size)) cv2.imshow('image', face) cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff // Esc if key == 27: break else: print('Finished!') break","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"Dlib","slug":"Dlib","permalink":"http://wenbo.fun/tags/Dlib/"}]},{"title":"人脸识别：概述","date":"2017-12-07T13:42:08.000Z","path":"2017/12/07/人脸识别1/","text":"主环境 opencv TensorFlow python3 dlib 具体搭建方式— 传送门 流程1. Get_faces 获取图片集获取所要识别的人脸的图片集最快的方法就是使用程序用摄像头拍照，要获取足够多的照片，得坐在电脑面前不停得给自己的脸摆各种姿势，这样可以提高训练后识别自己的成功率，这里先后采取了opencv和dlib自带人脸检测采集，虽然opencv识别比较快，但实际应用中会识别出一些奇怪的东西当作人脸, 所以程序采用了dlib来识别人脸。 dlib识别人脸获取图片集 2. Set_other_people 获取其他人脸图片集人脸图片集网上有很多，这里给出其中一个: 网址 下载 下载解压到项目目录下的input_img目录下,接下来使用dlib来批量识别图片中的人脸部分，并保存到指定目录other_faces下. dlib批量识别其他图片集 3. Train_faces 训练模型通过 CNN 训练数据,训练之后的数据会保存在当前目录下。 CNN 训练数据 4. Is_my_face s使用模型进行识别使用摄像头拍拍摄，在画面中标注出人脸。 进行识别","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"Environment","slug":"Environment","permalink":"http://wenbo.fun/tags/Environment/"}]},{"title":"Windows配置opencv3+python3+tensorflow环境","date":"2017-11-24T07:21:04.000Z","path":"2017/11/24/Win10配置opencv3+python3环境/","text":"Requirements WIN10/WIN7 64bit Anaconda3-5.0.1-Windows-x86_64 opencv_python-3.3.1+contrib-cp35-cp35m-win_amd64.whl python3.5 numpy-1.13.3+mkl-cp35-cp35m-win_amd64机器学习相关 ↓ dlib-18.17.100-cp35-none-win_amd64.whl tensorflow-1.4.0-cp35-cp35m-win_amd64.whl scikit_learn-0.19.1-cp35-cp35m-win_amd64.whl 注： 版本可以自己选择，只要注意版本号对上就行。其他额外依赖自行下载。 Anaconda概述Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 这里先解释下conda、anaconda这些概念的差别。conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。 conda的设计理念——conda将几乎所有的工具、第三方包都当做package对待，甚至包括python和conda自身！因此，conda打破了包管理与环境管理的约束，能非常方便地安装各种版本python、各种package并方便地切换。 Conda的常用操作1234567891011121314151617181920212223242526272829# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy# 更新conda，保持conda最新conda update conda# 更新anacondaconda update anaconda# 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 创建python环境 123456789101112# 创建环境conda create -n your_env_name python=X.X（2.7、3.6等）#使用激活(或切换不同python版本)的虚拟环境,使用python --version可以检查当前python版本是否为想要的。activate your_env_name#虚拟环境中安装额外的包conda install -n your_env_name [package]#关闭虚拟环境。deactivate#删除虚拟环境conda remove -n your_env_name --all#删除环境中的某个包conda remove --name $your_env_name $package_name 配置创建一个python3.5环境安装完成后，打开Anaconda Navigator程序,创建一个新环境。 选择一个python版本，这里选择3.5.环境名称可以随便取。 鼠标左键点击进入 terminal。 进入你下载的文件夹进行pip安装numpy,注意版本要匹配。 安装opencvpip安装opencv_python。 进入python，import cv2测试，没报错一般就是成功了。 安装 dlib 和 scikit_learn同上，略。 注：dlib 建议下载最新版本。 安装 TensorFlowpip安装 tensorflow-1.4.0-cp35-cp35m-win_amd64. 测试：","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://wenbo.fun/tags/TensorFlow/"},{"name":"环境配置","slug":"环境配置","permalink":"http://wenbo.fun/tags/环境配置/"},{"name":"Opencv","slug":"Opencv","permalink":"http://wenbo.fun/tags/Opencv/"},{"name":"Python","slug":"Python","permalink":"http://wenbo.fun/tags/Python/"}]},{"title":"GIT与GITHUB的使用","date":"2017-09-22T09:59:54.000Z","path":"2017/09/22/GIT与GITHUB的使用/","text":"绑定 SSH在本地电脑安装完GIT、Hexo或jekyll，在自己GITHUB账户建立了一个yourname.github.io的respository后，我们可以绑定 ssh来更加方便地push或pull我们的代码。 获取并绑定 SSH key打开git bash，输入ssh-keygen -t rsa命令，指定 RSA算法生成密钥，回车三次，密码不用输，生成两个隐藏文件id_rsa和id_rsa.pub，一般在下面位置。 Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username.ssh 接下来就把公钥id_rsa.pub的内容拷贝到 GitHub需要的地方就可以了。如下： 验证是否成功，在Git Bash中输入ssh -T git@github.com输入yes进行测试： 如图就是成功。 用 GIT 提交代码到 Github情况1：本地没 Git 仓库直接将远程仓库clone到本地。通过clone命令创建的本地仓库，其本身就是一个 Git 仓库了，不用咱们再进行init初始化操作啦，而且自动关联远程仓库。咱们只需要在这个仓库进行修改或者添加等操作，然后commit即可。 引用于通过 Git 将代码提交到 GitHub 情况2： 本地有 Git 仓库我们新建一个仓库做演示，进入 git bash，初始化仓库。进入该“仓库”，git init初始化,然后，输入git remote add origin https://github.com/yourname/test.git命令，关联远程仓库，其中origin为远程仓库的名字(默认，可以自己取)： git pull origin master命令，同步远程仓库和本地仓库： 若第一次使用，会叫你设置邮箱和名字，按照说明做就是。 再回到本地仓库，会发现远程的README已经同步到了本地，接下来，在本地仓库新建一个名为test.txt的测试文件,输入git add和git commit命令，将文件test.txt添加并提交到本地仓库，再输入git push origin master命令，将本地仓库修改（或者添加）的内容提交到远程仓库： 最后看看是否提交成功： 更多关于Git： Git Community Book 中文版 强调：在咱们向远程仓库提交代码的时候，一定要先进行pull操作，再进行push操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是第二种提交代码的情况，很容易就出现问题。","tags":[{"name":"GIT","slug":"GIT","permalink":"http://wenbo.fun/tags/GIT/"}]}]