[{"title":"Python教程(2/3)","date":"2018-02-03T05:24:08.000Z","path":"2018/02/03/myPython-a/","text":"面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的 类（Class） 的概念。给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的 方法（Method）。数据封装、继承和多态是面向对象的三大特点，我们后面会详细讲解。 类和实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。 仍以Student类为例，在Python中，定义类是通过class关键字： 12class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的： 12345&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x10a67a590&gt;&gt;&gt;&gt; Student&lt;class '__main__.Student'&gt; 可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。 可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性: 123&gt;&gt;&gt; bart.name = 'Bart Simpson'&gt;&gt;&gt; bart.name'Bart Simpson' 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去： 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 特殊方法__init__前后分别有两个下划线！！！ 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。 数据封装 面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩： 12345 &gt;&gt;&gt; def print_score(std):... print('%s: %s' % (std.name, std.score))...&gt;&gt;&gt; print_score(bart)Bart Simpson: 59 但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为 类的方法 ： 12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。封装的另一个好处是可以给Student类增加新的方法，比如get_grade： 12345678910class Student(object): ... def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C' 同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节： 1234lisa = Student('Lisa', 99)bart = Student('Bart', 59)print(lisa.name, lisa.get_grade())print(bart.name, bart.get_grade()) 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。 但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.score59&gt;&gt;&gt; bart.score = 99&gt;&gt;&gt; bart.score99 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法： 12345678class Student(object): ... def get_name(self): return self.__name def get_score(self): return self.__score 如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法,对参数做检查，避免传入无效的参数： 12345678class Student(object): ... def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError('bad score') 需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt; bart._Student__name'Bart Simpson' 但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。 最后注意下面的这种 错误写法： 123456&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 设置__name变量！&gt;&gt;&gt; bart.__name'New Name' 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试： 12&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name'Bart Simpson' 继承和多态在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行. 要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量： 1234567class Animal(object): def run(self): print('Animal is running...')def run_twice(animal): animal.run() animal.run() 当我们传入Animal的实例时，run_twice()就打印出： 123&gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running... 现在，如果我们再定义一个Tortoise类型，也从Animal派生： 123class Tortoise(Animal): def run(self): print('Tortoise is running slowly...') 当我们调用run_twice()时，传入Tortoise的实例： 123&gt;&gt;&gt; run_twice(Tortoise())Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思。 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的 “开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 123class Timer(object): def run(self): print('Start...') 这就是动态语言的 鸭子类型，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的 “file-like object” 就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为 “file-like object” 。许多函数接收的参数就是 “file-like object”，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 获取对象信息当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？ 使用type() type()函数返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同： 12345678&gt;&gt;&gt; type(123)==intTrue&gt;&gt;&gt; type('abc')==type('123')True&gt;&gt;&gt; type('abc')==strTrue&gt;&gt;&gt; type('abc')==type(123)False 判断基本数据类型可以直接写int，str等，但如果要判断一个对象是否是函数怎么办？可以使用types模块中定义的常量： 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue 使用isinstance() 对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。 我们回顾上次的例子，如果继承关系是： 1object -&gt; Animal -&gt; Dog -&gt; Husky 那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象： 123&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky() 然后，判断： 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(h, Dog)True isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。 能用type()判断的基本类型也可以用isinstance()判断： 123456&gt;&gt;&gt; isinstance('a', str)True&gt;&gt;&gt; isinstance(123, int)True&gt;&gt;&gt; isinstance(b'a', bytes)True 并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple： 1234&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 使用dir() 如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; 'ABC'.__len__()3 我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法： 1234567&gt;&gt;&gt; class MyDog(object):... def __len__(self):... return 100...&gt;&gt;&gt; dog = MyDog()&gt;&gt;&gt; len(dog)100 剩下的都是普通属性或方法，比如lower()返回小写的字符串： 12&gt;&gt;&gt; 'ABC'.lower()'abc' 仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态： 1234567&gt;&gt;&gt; class MyObject(object):... def __init__(self):... self.x = 9... def power(self):... return self.x * self.x...&gt;&gt;&gt; obj = MyObject() 紧接着，可以测试该对象的属性： 12345678910111213&gt;&gt;&gt; hasattr(obj, 'x') # 有属性'x'吗？True&gt;&gt;&gt; obj.x9&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？False&gt;&gt;&gt; setattr(obj, 'y', 19) # 设置一个属性'y'&gt;&gt;&gt; hasattr(obj, 'y') # 有属性'y'吗？True&gt;&gt;&gt; getattr(obj, 'y') # 获取属性'y'19&gt;&gt;&gt; obj.y # 获取属性'y'19 如果试图获取不存在的属性，会抛出AttributeError的错误： 1234&gt;&gt;&gt; getattr(obj, 'z') # 获取属性'z'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'MyObject' object has no attribute 'z' 可以传入一个default参数，如果属性不存在，就返回默认值： 12&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404 也可以获得对象的方法： 123456789&gt;&gt;&gt; hasattr(obj, 'power') # 有属性'power'吗？True&gt;&gt;&gt; getattr(obj, 'power') # 获取属性'power'&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的81 小结 通过内置的一系列函数，我们可以对任意一个Python对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。一个正确的用法的例子如下： 1234def readImage(fp): if hasattr(fp, 'read'): return readData(fp) return None 假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取。hasattr()就派上了用场。 请注意，在Python这类动态语言中，根据鸭子类型，有read()方法，不代表该fp对象就是一个文件流，它也可能是网络流，也可能是内存中的一个字节流，但只要read()方法返回的是有效的图像数据，就不影响读取图像的功能。 实例属性和类属性由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量： 123456class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90 但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有： 12class Student(object): name = 'Student' 当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下： 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = 'Student'...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 从上面的例子可以看出，在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 面向对象高级编程使用slots正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class： 12class Student(object): pass 然后，尝试给实例绑定一个属性： 1234&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'Michael' # 动态给实例绑定一个属性&gt;&gt;&gt; print(s.name)Michael 还可以尝试给实例绑定一个方法： 12345678&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法... self.age = age...&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法&gt;&gt;&gt; s.age # 测试结果25 但是，给一个实例绑定的方法，对另一个实例是不起作用的： 12345&gt;&gt;&gt; s2 = Student() # 创建新的实例&gt;&gt;&gt; s2.set_age(25) # 尝试调用方法Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'set_age' 为了给所有实例都绑定方法，可以给class绑定方法： 1234&gt;&gt;&gt; def set_score(self, score):... self.score = score...&gt;&gt;&gt; Student.set_score = set_score 给class绑定方法后，所有实例均可调用： 123456&gt;&gt;&gt; s.set_score(100)&gt;&gt;&gt; s.score100&gt;&gt;&gt; s2.set_score(99)&gt;&gt;&gt; s2.score99 通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。 使用slots 但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性： 12class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称 然后，我们试试： 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score' 由于score没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的： 12345&gt;&gt;&gt; class GraduateStudent(Student):... pass...&gt;&gt;&gt; g = GraduateStudent()&gt;&gt;&gt; g.score = 9999 除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 使用@property在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改： 12s = Student()s.score = 9999 这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数： 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value 现在，对任意的Student实例进行操作，就不能随心所欲地设置score了： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.set_score(60) # ok!&gt;&gt;&gt; s.get_score()60&gt;&gt;&gt; s.set_score(9999)Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。 有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！ 还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性： 123456789101112class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2015 - self._birth 上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。 多重继承通过多重继承，一个子类就可以同时获得多个父类的所有功能。 MixIn 在设计类的继承关系时，通常，主线都是单一继承下来的，但是，如果需要“混入”额外的功能，通过多重继承就可以实现。这种设计通常称之为MixIn。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。 比如，编写一个多进程模式的TCP服务，定义如下： 12class MyTCPServer(TCPServer, ForkingMixIn): pass 编写一个多线程模式的UDP服务，定义如下： 12class MyUDPServer(UDPServer, ThreadingMixIn): pass 如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn： 12class MyTCPServer(TCPServer, CoroutineMixIn): pass 这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。 由于Python允许使用多重继承，因此，MixIn就是一种常见的设计,只允许单一继承的语言（如Java）不能使用MixIn的设计。 定制类看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。 __slots__我们已经知道怎么用了，__len__()方法我们也知道是为了能让class作用于len()函数。 除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们 定制类。 str 我们先定义一个Student类，打印一个实例： 123456&gt;&gt;&gt; class Student(object):... def __init__(self, name):... self.name = name...&gt;&gt;&gt; print(Student('Michael'))&lt;__main__.Student object at 0x109afb190&gt; 怎么才能打印得好看呢？只需要定义好str()方法，返回一个好看的字符串就可以了： 12345678&gt;&gt;&gt; class Student(object):... def __init__(self, name):... self.name = name... def __str__(self):... return 'Student object (name: %s)' % self.name...&gt;&gt;&gt; print(Student('Michael'))Student object (name: Michael) 这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看： 123&gt;&gt;&gt; s = Student('Michael')&gt;&gt;&gt; s&lt;__main__.Student object at 0x109afb310&gt;","tags":[{"name":"Python","slug":"Python","permalink":"http://wenbo.fun/tags/Python/"}]},{"title":"ML_Foundation","date":"2018-01-26T05:39:12.000Z","path":"2018/01/26/MLforward/","text":"Linear AlgebraPoint Scalar、Vector、Tensor Identity Matrix、$A^T$ (transpose of A) Matrix-Vector Product Span、Generate Space、Subspace、Eigenspace Linear Dependent、Rank $[A|b]$ (Augmented Matrix) Matrix Multiplication Inverse of a Matrix Basis Eigenvalue &amp; Eigenvector Characteristic Polynomial、Similar Matrix Diagonalizable Orthogonality 概率论、信息论数值计算","tags":[{"name":"Other","slug":"Other","permalink":"http://wenbo.fun/tags/Other/"}]},{"title":"Python教程(1/3)","date":"2018-01-10T07:49:18.000Z","path":"2018/01/10/myPython/","text":"Python Python 3 From Python基础Python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用Tab和空格。 数据类型和变量整数十六进制用0x前缀和0-9，a-f表示。 注: Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648~2147483647。 Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大） Floating point numbers are usually implemented using double in C. ——Python官方文档 浮点数(小数)科学计数法: 0.000012可以写成1.2e-5字符串字符串是以单引号’或双引号”括起来的任意文本 转义字符\\,如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r&#39;&#39;表示’’内部的字符串默认不转义. 1234&gt;&gt;&gt; print('\\\\\\t\\\\')\\ \\&gt;&gt;&gt; print(r'\\\\\\t\\\\')\\\\\\t\\\\ 布尔值 True、False 布尔值可以用and、or和not运算 空值 空值是Python里一个特殊的值，用None表示。 $ None /neq 0 $ 变量变量不仅可以是数字，还可以是任意数据类型。 在Python中，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。这种变量本身类型不固定的语言称之为 动态语言。 注:123a = &apos;ABC&apos;b = aa = &apos;XYZ&apos; 执行b = a，解释器创建了变量b，并把b指向a指向的字符串’ABC’,a改变值时b不改变。 常量在Python中，通常用全部大写的变量名表示常量，如: PI 在Python中，有两种除法，一种除法是/,还有一种除法是//，称为地板除，只取结果的整数部分。 字符串和编码字符编码ASCII 编码GB2312 编码(中文编)Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间。所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。 计算机系统通用的字符编码工作方式：在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。 Python的字符串字符串是以Unicode编码的。对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文' 如果知道字符的整数编码，还可以用十六进制这么写str： 12&gt;&gt;&gt; '\\u4e2d\\u6587''中文' 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes,一个字符都只占用一个字节。Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b'ABC' 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 1234&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 在bytes中，无法显示为ASCII字符的字节，用\\x##显示。 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法： 1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文' 如果bytes中包含无法解码的字节，decode()方法会报错,如果bytes中只有一小部分无效的字节，可以传入errors=&#39;ignore&#39;忽略错误的字节： 12&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中' 要计算str包含多少个字符，可以用len()函数,如果换成bytes，len()函数就计算字节数： 123456&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6 当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。注: 申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，你还要确保文本编辑器正在使用UTF-8 without BOM编码。 格式化和C语言是一致常见的占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 %2d 格式化整数 格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 12345678&gt;&gt;&gt; print('%02d' % 45)45&gt;&gt;&gt; print('%03d' % 45)045&gt;&gt;&gt; print('%.2f' % 3.1415926)3.14&gt;&gt;&gt; print('%05.2f' % 3.1415926)03.14 format()另一种格式化字符串的方法是使用字符串的format()方法,它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 12&gt;&gt;&gt; '&#123;0&#125;成绩提升了 &#123;1:.2f&#125;%'.format('小明', 17.125)'小明成绩提升了 17.1%' list和tuplelistPython内置的一种数据类型。list是一种有序的集合，可以随时添加和删除其中的元素,l里面的元素的数据类型可以不同。用len()函数可以获得list元素的个数。用索引来访问与其他语言类似。 12345classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3 可以用-1做索引，直接获取最后一个元素,以此类推，可以获取倒数第2个、倒数第3个： 1234&gt;&gt;&gt; classmates[-1]'Tracy'&gt;&gt;&gt; classmates[-3]'Michael' list是一个可变的有序表，可以用append追加元素到末尾： 1&gt;&gt;&gt; classmates.append('Adam') insert插入到指定的位置: 1&gt;&gt;&gt; classmates.insert(1, 'Jack') 删除指定位置的元素，用pop(i)方法删除list末尾的元素，用pop()方法： 12&gt;&gt;&gt; classmates.pop()'Adam' list元素也可以是另一个list: 123&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4 要拿到 php 可以写s[2][1]，因此s可以看成是一个二维数组 tupletuple和list非常类似，但是tuple一旦初始化就不能修改,用的是()。 1&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy') 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 而 t = (1) 代表t是1这个数。 tuple中可含有可变的list。12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y']) tuple指向变化: tuple一开始指向的list并没有改成别的list。这就是指向不变。 判断与循环条件判断if-else: 循环for: 1234sum = 0for x in range(101): sum = sum + xprint(sum) while:12while n &gt; 0: n++ break and continue:continue跳过当前的这次循环，直接开始下一次循环。 使用dict和setDictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。ex: 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 通过key放入数据： 123&gt;&gt;&gt; d['Adam'] = 67&gt;&gt;&gt; d['Adam']67 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在： 12&gt;&gt;&gt; 'Thomas' in dFalse 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value： 123&gt;&gt;&gt; d.get('Thomas')&gt;&gt;&gt; d.get('Thomas', -1)-1 注：dict内部存放的顺序和key放入的顺序是没有关系的,dict是用空间来换取时间的一种方法。 dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。通过key计算位置的算法称为哈希算法（Hash）。 要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key,tuple可以作为key。 Setset是一组key的集合，但不存储value。要创建一个set，需要提供一个list(tuple也行)作为输入集合,重复元素在set中自动被过滤： 123&gt;&gt;&gt; s = set([1, 1, 2, 2, 4, 3, 3, 1, 2])&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125; 通过add(key)方法可以添加元素到set中: 123&gt;&gt;&gt; s.add(0)&gt;&gt;&gt; s&#123;0, 1, 2, 3, 4&#125; remove(key)方法可以删除元素： 123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;0, 1, 2, 3&#125; set可以看成数学意义上的无序、无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 试试不变对象tuple: 12345678&gt;&gt;&gt; b = set ([(2,3),4])&gt;&gt;&gt; b&#123;(2, 3), 4&#125;&gt;&gt;&gt; b = set ([(2,3),[4,5]])Traceback (most recent call last): File \"&lt;pyshell#64&gt;\", line 1, in &lt;module&gt; b = set ([(2,3),[4,5]])TypeError: unhashable type: 'list' 函数内置函数 Built-in Functions 定义函数定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号: 12345def my_abs(x): if x &gt;= 0: return x else: return -x 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）： 123&gt;&gt;&gt; from abstest import my_abs &gt;&gt;&gt; my_abs(-9) 9 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 12if age &gt;= 18: pass 缺少了pass，代码运行就会有语法错误。 返回多个值 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny Python的函数返回多值其实就是返回一个tuple，多个变量可以同时接收一个tuple,在语法上，返回一个tuple可以省略括号。 123456&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0&gt;&gt;&gt;move(100, 100, 60, math.pi / 6)(151.96152422706632, 70.0) 函数的参数Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 位置参数写一个计算$x^n$函数: 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s power(x, n) 函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。 默认参数 由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样，当我们调用power(5)时，相当于调用power(5, 2)： 1234&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(5, 2)25 设置默认参数时，有几点要注意： 必选参数在前，默认参数在后，否则Python的解释器会报错。 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 Python函数在定义的时候，默认参数L的值就被计算出来了，即[].要注意如下情况: 123def add_end(L=[]): L.append('END') return L 用 [] 作默认参数进行调用: 12&gt;&gt;&gt; add_end()['END'] 第一次调用没毛病，但是: 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 可以用None这个不变对象来实现： 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 可变参数定义一个list或tuple参数： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 调用: 1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84 定义可变参数: 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 调用: 1234&gt;&gt;&gt; calc(1, 2, 3)14&gt;&gt;&gt; calc(1, 3, 5, 7)84 Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 1函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数,也可以传入任意个数的关键字参数： 123456&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125;&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 命名关键字参数 对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 仍以person()函数为例，我们希望检查是否有city和job参数： 123456789101112131415161718192021def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw)``` 调用者仍可以传入不受限制的关键字参数,如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：```pythondef person(name, age, *, city, job): print(name, age, city, job)``` 和关键字参数`**kw`不同，命名关键字参数需要一个特殊分隔符`*`，`*`后面的参数被视为命名关键字参数。如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符`*`了：```pythondef person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错。命名关键字参数可以有缺省值: 12345678910111213def person(name, age, *, city='Beijing', job): print(name, age, city, job)``` **参数组合**在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。```pythondef f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的: 123456789&gt;&gt;&gt; args = (1, 2, 3, 4, 5)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)f1(*args, **kw)a = 1 b = 2 c = 3 args = (4, 5) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 可见，使用太多的组合，函数接口的可理解性很差。 参数检查 数据类型检查可以用内置函数isinstance()实现： 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：12345&gt;&gt;&gt; my_abs('A')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 3, in my_absTypeError: bad operand type 递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 利用递归函数移动汉诺塔: 1234567def move(n, a, b, c): if n == 1: print('move', a, '--&gt;', c) else: move(n-1, a, c, b) move(1, a, b, c) move(n-1, b, a, c) 调用: 1move(4, 'A', 'B', 'C') 高级特性在Python中，代码不是越多越好，而是越少越好。代码不是越复杂越好，而是越简单越好。 切片先创建一个0-99的数列： 1&gt;&gt;&gt; L = list(range(100)) 通过切片轻松取出某一段数列。比如前10个数： 12&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数: 12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前10个数，每两个取一个：12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 所有数，每5个取一个： 12&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 只写[:]就可以原样复制一个list。tuple也可以用切片操作，只是操作的结果仍是tuple字符串&#39;xxx&#39;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串 1234&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 迭代如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。在Python中，迭代是通过for ... in来完成的，java类似。 123456&gt;&gt;&gt; d = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; for key in d: print(key)acb 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 如何 判断 一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： isinstance是Python中的一个内建函数。是用来判断一个对象是否是一个已知的类型。 1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： 123456&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']): print(i, value)0 A1 B2 C 类似同时引入两个变量: 123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 列表生成式列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))，但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)...&gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 生成的元素x * x放到前面，后面跟for循环,for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名: 12&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到&gt;&gt;&gt; [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 列表生成式也可以使用两个变量来生成list： 123&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] 最后把一个list中所有的字符串变成小写： 123&gt;&gt;&gt; L = ['Hello', 'World', 'IBM', 'Apple']&gt;&gt;&gt; [s.lower() for s in L]['hello', 'world', 'ibm', 'apple'] 生成器通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： 123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 怎么打印出generator的每一个元素呢？一个一个打印出来，可以通过next()函数获得generator的下一个返回值： 12345&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g) 一般用for循环: 1234567891011121314&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)...0149162536496481 如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现,如斐波拉契数列: 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done' 注: a, b = b, a + b 相当于: 123t = (b, a + b) # t是一个tuplea = t[0]b = t[1] fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。也就是说，上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print(b)改为yield b就可以了： 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done' 如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。 迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种：一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为**可迭代对象：Iterable。可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可以使用isinstance()判断一个对象是否是Iterable对象或Iterator对象。 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。把list、dict、str等Iterable变成Iterator可以使用iter()函数： 123456789101112131415&gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterator)True&gt;&gt;&gt; isinstance([], Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;, Iterator)False&gt;&gt;&gt; isinstance('abc', Iterator)False&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 函数式编程函数就是面向过程的程序设计的基本单元。函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。 函数式编程的一个 特点 就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数！Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。 高阶函数Higher-order function一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。一个最简单的高阶函数： 12def add(x, y, f): return f(x) + f(y) 当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为： 12345x = -5y = 6f = absf(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11return 11 编写高阶函数，就是让函数的参数能够接收别的函数。 map/reducemapmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 举例说明，比如我们有一个函数 $f(x)=x^2$ ，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下： 12345678910111213141516 f(x) = x * x │ │ ┌───┬───┬───┬───┼───┬───┬───┬───┐ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼[ 1 2 3 4 5 6 7 8 9 ] │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼ ▼[ 1 4 9 16 25 36 49 64 81 ] 现在，我们用Python代码实现： 123456&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; list(r)[1, 4, 9, 16, 25, 36, 49, 64, 81] map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。 你可能会想，不需要map()函数，写一个循环，也可以计算出结果： 1234L = []for n in [1, 2, 3, 4, 5, 6, 7, 8, 9]: L.append(f(n))print(L) 的确可以，但是，从上面的循环代码，能一眼看明白 把f(x)作用在list的每一个元素并把结果生成一个新的list 吗？ 所以，map()作为高阶函数，事实上它把运算规则 抽象 了，因此，我们不但可以计算简单的 $f(x)=x^2$ ，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串： 12&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))['1', '2', '3', '4', '5', '6', '7', '8', '9'] 只需要一行代码。 reducereduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做 累积计算，其效果就是： 1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 把序列[1, 3, 5, 7, 9]变换成整数13579： 123456&gt;&gt;&gt; from functools import reduce&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])13579 考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数： 12345678910from functools import reduceDIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s)) 还可以用lambda函数进一步简化成： 123456789from functools import reduceDIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;def char2num(s): return DIGITS[s]def str2int(s): return reduce(lambda x, y: x * 10 + y, map(char2num, s)) lambda-&gt;参见后续的 匿名函数。 filterPython内建的filter()函数用于过滤序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： 12345def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果: [1, 5, 9, 15] 把一个序列中的空字符串删掉，可以这么写： 12345def not_empty(s): return s and s.strip()list(filter(not_empty, ['A', '', 'B', None, 'C', ' ']))# 结果: ['A', 'B', 'C'] 用filter求素数 计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单： 首先，列出从2开始的所有自然数，构造一个序列： 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉： 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉： 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数5，然后用5把序列的5的倍数筛掉： 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 不断筛下去，就可以得到所有的素数。 用Python来实现这个算法，可以先构造一个从3开始的奇数序列： 12345def _odd_iter(): n = 1 while True: n = n + 2 yield n 注意这是一个 生成器，并且是一个无限序列。然后定义一个筛选函数： 12def _not_divisible(n): return lambda x: x % n &gt; 0 最后，定义一个生成器，不断返回下一个素数： 1234567def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。 由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件： 打印1000以内的素数： 12345for n in primes(): if n &lt; 1000: print(n) else: break 注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。 练习 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()筛选出回数： 提示: 12def is_palindrome(n): return n == int(str(n)[::-1]) sortedPython里的 排序算法 Python内置的sorted()函数就可以对list进行排序,此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序： 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 上述例子可以看出，高阶函数的抽象能力是非常强大的。 返回函数函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：12345def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数： 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数： 123&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt; 调用函数f时，才真正计算求和的结果： 12&gt;&gt;&gt; f()25 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为 闭包（Closure） 的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数： 1234&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2False 闭包返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被另一个函数引用，所以，闭包用起来简单，实现起来可不容易。另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子： 123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是： 123456&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变： 123456789def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs 缺点是代码较长，可利用lambda函数缩短代码。 练习利用闭包返回一个计数器函数，每次调用它返回递增整数： 12345678def createCounter(): def f(): i=0 while True: i += 1 yield i a = f() return lambda: next(a) 调用： 12345&gt;&gt;&gt; a= createCounter()&gt;&gt;&gt; a()1&gt;&gt;&gt; a()2 匿名函数当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算 $f(x)=x^2$ 时，除了定义一个f(x)的函数外，还可以直接传入匿名函数： 12&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[1, 4, 9, 16, 25, 36, 49, 64, 81] 通过对比可以看出，匿名函数lambda x: x * x实际上就是： 12def f(x): return x * x 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个 限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数： 12345&gt;&gt;&gt; f = lambda x: x * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;&gt;&gt;&gt; f(5)25 装饰器由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。 123456&gt;&gt;&gt; def now():... print('2015-3-25')...&gt;&gt;&gt; f = now&gt;&gt;&gt; f()2015-3-25 函数对象有一个__name__属性，可以拿到函数的名字： 1234&gt;&gt;&gt; now.__name__'now'&gt;&gt;&gt; f.__name__'now' 现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为 装饰器（Decorator）。本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下： 12345def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处： 123@logdef now(): print('2015-3-25') 调用: 123&gt;&gt;&gt; now()call now():2015-3-25 把@log放到now()函数的定义处，相当于执行了语句： 1now = log(now) 因为wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用，在wrapper()函数内，首先打印日志，再紧接着调用原始函数。如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本： 1234567def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator 这个3层嵌套的decorator用法如下： 123@log('execute')def now(): print('2015-3-25') 和两层嵌套的decorator相比，3层嵌套的效果是这样的： 1now = log('execute')(now) 我们来剖析上面的语句，首先执行log(&#39;execute&#39;)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。 以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的&#39;now&#39;变成了&#39;wrapper‘： 12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个wrapper()函数名字就是&#39;wrapper&#39;，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下： 12345678import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 或者针对带参数的decorator： 12345678910import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator import functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。 偏函数Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值： 12&gt;&gt;&gt; int2('1000000', base=10)1000000 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。 模块在Python中，一个.py文件就称之为一个 模块（Module）。为了避免模块名冲突，Python又引入了按目录来组织模块的方法，称为 包（Package）。每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块。 创建自己的模块时，要注意： 模块名要遵循Python变量命名规范，不要使用中文、特殊字符； 模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行import abc，若成功则说明系统存在此模块。 使用模块使用模块的第一步，就是导入该模块： 1import sys 当我们在命令行运行模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。 12if __name__=='__main__': test() 作用域类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如__author__ ，__name__就是特殊变量.类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； 之所以我们说private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子： 1234567891011def _private_1(name): return 'Hello, %s' % namedef _private_2(name): return 'Hi, %s' % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的 代码封装和抽象 的方法，即：外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 安装第三方模块在Python中，安装第三方模块，是通过包管理工具pip完成的。比如: 1pip install Pillow 一般来说，第三方库都会在Python官方的pypi.python.org网站注册. 另外，可以直接使用 Anaconda。 模块搜索路径 默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中： 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path 添加自己的搜索目录，有两种方法：一是直接修改sys.path，添加要搜索的目录： 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append('/Users/michael/my_py_scripts') 这种方法是在运行时修改，运行结束后失效。第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。","tags":[{"name":"Python","slug":"Python","permalink":"http://wenbo.fun/tags/Python/"}]},{"title":"分支限界---批处理作业调度","date":"2017-12-31T07:56:44.000Z","path":"2017/12/31/sf012/","text":"批处理作业调度问题描述 计算机算法设计与分析(第四版)，王晓东 n 个作业的集合: $$J={J1,J2,…,Jn}$$ 第 i 个作业需要机器 j 的处理时间: $$ t_{ij}$$ 已安排作业集合: $$M⊆{1,2…,n}$$ 所有作业在机器2完成时间和（包括等待时间）: $$f=\\sum_{i=1}^n{F_{2i}}$$ 以某个节点为根的子树中所含叶节点的完成时间和可表示为:$$f=\\sum_{i \\in M} F_{2i} + \\sum_{i \\notin M} F_{2i} $$ 实例: 排列树: 设 |M|=r , p_k 是第k个安排的作业,相应的作业调度为: $${p_k,k=1,2,……n}$$其中。如果从节点E到叶节点L的路上，每一个作业p_k在机器1上完成处理后都能立即在机器2上开始处理，即从p_r+1开始，机器1没有空闲时间,则对于该叶节点有:$$\\sum_{i \\notin M}F_{2i} = \\sum_{k=r+1}^n[F_{1p_r}+(n-k+1)t_{1p_k}+t_{2p_k}]$$ 式子中(n-k+1),因为是求的是作业完成时间和，所以，后续的(n-k+1)个作业完成时间和都得算上 如果不是按照上面安排，则s1会增加，从而有:$$\\sum_{i \\notin M}F_{2i} \\ge S_1 $$类似，从p_r+1开始，让机器2没有空闲时间:$$\\sum_{i \\notin M}F_{2i} = \\sum_{k=r+1}^n[ \\max(F_{2p_r},F_{1p_r} + \\min\\limits_{i \\notin M} t_{1i}) + (n-k+1)t_{2p_k}] = S_2$$从而得到下界(限界函数):$$f \\ge \\sum_{i \\notin M}F_{2i} + \\max \\{S_1,S_2\\}$$ java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205/** * 批处理作业调度问题--优先队列式分支限界法 **/import java.util.Collections;import java.util.LinkedList;public class BBFlow &#123; public int n;//作业数 public int bestc;//最小完成时间和 public int [][]m;//个作业所需的处理时间数组 public int [][]b;//个作业所需的处理时间排序数组 public int[][] a;//数组m和b的对应关系数组 public int[] bestx;//最优解 public boolean[][] y;//工作数组 public BBFlow(int n,int[][] m)&#123; this.n=n; bestc=10000; this.m=m; b=new int[n][2]; a=new int[n][2]; bestx=new int[n]; y=new boolean[n][2]; &#125; public void swap(int[][] b,int i,int j,int k,int t)&#123; int temp=b[i][j]; b[i][j]=b[k][t]; b[k][t]=temp; &#125; public void swap(int[] x,int i,int j)&#123; int temp=x[i]; x[i]=x[j]; x[j]=temp; &#125;/*** 对个作业在机器1和2上所需时间排序*/ public void sort()&#123; int[] c=new int[n]; for(int j=0;j&lt;2;j++)&#123; for(int i=0;i&lt;n;i++)&#123; b[i][j]=m[i][j]; c[i]=i; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int k=n-1;k&gt;i;k--)&#123; if(b[k][j]&lt;b[k-1][j])&#123; swap(b,k,j,k-1,j); swap(c,k,k-1); &#125; &#125; &#125; for(int i=0;i&lt;n;i++) a[c[i]][j]=i; &#125; &#125; /** * 计算完成时间和下界 * @param enode * @param f * @return */ public int bound(Nodes enode,int[] f)&#123; for(int k=0;k&lt;n;k++)&#123; for(int j=0;j&lt;2;j++)&#123; y[k][j]=false; &#125; &#125; for(int k=0;k&lt;enode.s;k++)&#123; for(int j=0;j&lt;2;j++)&#123; y[a[enode.x[k]][j]][j]=true; &#125; &#125; f[1]=enode.f[1]+m[enode.x[enode.s]][0]; f[2]=((f[1]&gt;enode.f[2])?f[1]:enode.f[2])+m[enode.x[enode.s]][1]; int sf2=enode.sf2+f[2]; int s1=0; int s2=0; int k1=n-enode.s; int k2=n-enode.s; int f3=f[2]; //计算s1的值 for(int j=0;j&lt;n;j++)&#123; if(!y[j][0])&#123; k1--; if(k1==n-enode.s-1) f3=(f[2]&gt;f[1]+b[j][0])?f[2]:f[1]+b[j][0]; s1+=f[1]+k1*b[j][0]; &#125; &#125; //计算s2的值 for(int j=0;j&lt;n;j++)&#123; if(!y[j][1])&#123; k2--; s1+=b[j][1]; s2+=f3+k2*b[j][1]; &#125; &#125; //返回完成时间和下界 return sf2+((s1&gt;s2)?s1:s2); &#125; /** * 优先队列式分支限界法解批处理作业调度问题 * @param nn * @return */ public int bbFlow(int nn)&#123; n=nn; sort();//对个作业在机器1和2上所需时间排序 LinkedList&lt;Nodes&gt; heap=new LinkedList&lt;Nodes&gt;(); Nodes enode =new Nodes(n); //搜索排列空间树 do&#123; if(enode.s==n)&#123; //叶节点 if(enode.sf2&lt;bestc)&#123; bestc=enode.sf2; for(int i=0;i&lt;n;i++)&#123; bestx[i]=enode.x[i]; &#125; &#125; &#125;else&#123; //产生当前扩展结点的儿子结点 for(int i=enode.s;i&lt;n;i++)&#123; swap(enode.x,enode.s,i); int[] f=new int[3]; int bb=bound(enode,f); if(bb&lt;bestc)&#123; //子树可能含有最优解 //结点插入最小堆 Nodes node=new Nodes(enode,f,bb,n); heap.add(node); Collections.sort(heap); &#125; swap(enode.x,enode.s,i); &#125;//完成结点扩展 &#125; //取下一个扩展结点 enode=heap.poll(); &#125;while(enode!=null&amp;&amp;enode.s&lt;=n); return bestc; &#125; public static void main(String[] args) &#123; int n=3; int[][] m=&#123;&#123;2,1&#125;,&#123;3,1&#125;,&#123;2,3&#125;&#125;;//m的下标从0开始 BBFlow f=new BBFlow(n,m); f.bbFlow(n); System.out.println(\"最优批处理作业调度顺序为：\"); for(int i=0;i&lt;n;i++) System.out.print((f.bestx[i]+1)+\" \"); System.out.println(); System.out.println(\"最优调度所需的最短时间为：\"+f.bestc); &#125;&#125;class Nodes implements Comparable&#123; int s;//已安排作业数 int sf2;//当前机器2上的完成时间和 int bb;//当前完成时间和下界 int[] f;//f[1]机器1上最后完成时间，f[2]机器2上最后完成时间 int[] x;//当前作业调度 public Nodes(int n)&#123; //最小堆结点初始化 x=new int[n]; for(int i=0;i&lt;n;i++) x[i]=i; s=0; f=new int[3]; f[1]=0; f[2]=0; sf2=0; bb=0; &#125; public Nodes(Nodes e,int[] ef,int ebb,int n)&#123; //最小堆新结点 x=new int[n]; for(int i=0;i&lt;n;i++) x[i]=e.x[i]; f=ef; sf2=e.sf2+f[2]; bb=ebb; s=e.s+1; &#125; @Override public int compareTo(Object o) &#123; int xbb=((Nodes) o).bb; if(bb&lt;xbb) return -1; if(bb==xbb) return 0; return 1; &#125;&#125;/*运行结果：最优批处理作业调度顺序为：1 3 2最优调度所需的最短时间为：18*/","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"分支限界---布线问题","date":"2017-12-30T11:07:34.000Z","path":"2017/12/30/sf011/","text":"分支限界与回溯回溯法盲目搜索从根节点出发，按照状态空间树的结构，向下搜索它的所有儿子结点，对不满足约束条件的儿子结点，把它丢弃；对满足约束条件的结点，继续相似搜索它的所有儿子结点。该搜索过程一直进行，当搜索到一个满足约束条件的叶结点时，就得到了一个可行解；或者所有的儿子结点都不满足约束条件时，该结点就被丢弃，向上回溯到它的父亲结点。 分支限界法启发式搜索 在结点估算沿着它的各儿子结点搜索时，目标函数可能取得的“界” 把儿子结点和目标函数可能取得的“界”，保存在优先队列或堆中 从队列或堆中选取“界”最大或最小的结点向下搜索，直到叶子结点 若叶子结点的目标函数的值，是结点表中的最大值或最小值，则沿叶子结点到根结点的路径所确定的解，就是问题的最优解，由该叶子结点所确定的目标函数的值，就是解这个问题所得到的最大值或最小值 界 对最小值问题，称为下界，意思是向下搜索所可能取得的值最小不会小于这些下界。 对最大值问题，称为上界，意思是向下搜索所可能取得的值最大不会大于这些上界。 子集树与排列树子集树问题可以理解为在一个集合中选取一个满足某种条件的子集。我们对待选集合任意排序，然后顺次对其中的元素给出两种决策： 左: 将当前元素选入集合右: 放弃当前元素 整个解空间所呈现出的是一棵二叉树。算法复杂度为$$O(2 ^ n)$$ E.g. 0-1背包问题 排列树问题可以理解为在一个集合的排列中寻找一个符合要求的排列。我们采用这样的策略： 每一次的决策都是从当前集合选出一个元素，将其余元素放入下次决策。当集合为空，我们生成了一个排列。 算法复杂度$$O(n!)$$ E.g. 旅行商问题 回溯与分支限界的比较 搜索模型的不同 回溯使用递归栈作为辅助，按既定顺序逐条搜索每一条从树根到叶子的路径。 分支限界法使用优先级队列或队列作为辅助，寻找“最优”路径。 目标不同 回溯法更为通用，而分支限界法用于寻找最优解 时间效率(搜索最优解问题) 回溯法搜索的时间正比于搜索解空间的大小 分支限界法的时间敏感于最优解所在位置，当最优解偏树根，则时间相对于搜索整个解空间树非常少。 空间效率 回溯法的空间消耗与解空间（最大）树高有关 分支限界法的空间消耗一般表现出广度优先搜索的特点，与解空间的宽度有关。 一般树高远小于树宽,所以可以认为分支限界法是回溯法的一种空间换时间的技术 布线问题问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度扩展节点: $$O(1)$$每个方格此为活结点进入队列最多一次，总结点数:$$O(mn)$$构造最短距离(L是最短路径的长度):$$O(L)$$ java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import java.util.LinkedList; import java.util.Scanner; /** * 布线问题 * @author Lican * */ public class WireRouter &#123; public int[][] grid;//方格阵列;=0表示该方格运行布线；=1表示被封锁，不允许布线 public int size;//方格阵列大小 public int pathLen;//最短线路长度 public LinkedList&lt;Position&gt; q;//扩展结点队列，用list存储 public Position start;//起始位置 public Position finish;//终点 public Position[] path;//最短路径 public WireRouter(int[][] grid,int size,Position start,Position finish)&#123; this.grid=grid; this.size=size; this.start=start; this.finish=finish; &#125; /** * 方格所在位置 * @author Lican * */ public static class Position&#123; public int row;//行 public int col;//列 public Position(int r ,int c)&#123; row=r; col=c; &#125; &#125; /** *计算从起始位置start到目标位置finish的最短布线路径 * @return 找到最短布线路径则返回true，否则返回false */ public boolean findPath()&#123; if(start.row==finish.row&amp;&amp;start.col==finish.col)&#123;//start==finish,最短路径为0 pathLen=0; return true; &#125; //初始化相对位移 Position[] offset=new Position[4]; offset[0]=new Position(0,1);//右 offset[1]=new Position(1,0);//下 offset[2]=new Position(0,-1);//左 offset[3]=new Position(-1,0);//上 //设置方格阵列“围墙”，方便处理方格边界的情况 for(int i=0;i&lt;=size+1;i++)&#123; grid[0][i]=grid[size+1][i]=1;//顶部和底部 grid[i][0]=grid[i][size+1]=1;//左边和右边 &#125; Position here=new Position(start.row,start.col); grid[start.row][start.col]=2;//数字0,1表示方格的开放或封锁所以，表示距离时，让所有距离都加2；起始位置的距离为0+2=2 int numOfNbrs=4;//相邻方格数 //以下为标记可达的方格位置 q=new LinkedList&lt;Position&gt;(); Position nbr=new Position(0,0); do&#123; //标记可达的相邻方格(每个方格有四个相邻方格) for(int i=0;i&lt;numOfNbrs;i++)&#123; nbr.row=here.row+offset[i].row; nbr.col=here.col+offset[i].col; if(grid[nbr.row][nbr.col]==0)&#123;//该方格未被标记，且该方格允许布线 grid[nbr.row][nbr.col]=grid[here.row][here.col]+1; if(nbr.row==finish.row&amp;&amp;nbr.col==finish.col) break; q.add(new Position(nbr.row,nbr.col)); &#125; &#125; //检测是否到达目标位置finish if(nbr.row==finish.row&amp;&amp;nbr.col==finish.col) break; if(q.isEmpty()) return false; here=q.poll(); &#125;while(true); //构造最短布线路径 pathLen=grid[finish.row][finish.col]-2; path=new Position[pathLen]; //从目标位置finish开始向起始位置回溯 here=finish; for(int j=pathLen-1;j&gt;=0;j--)&#123; path[j]=here; //找前驱位置 for(int i=0;i&lt;numOfNbrs;i++)&#123; nbr.row=here.row+offset[i].row; nbr.col=here.col+offset[i].col; if(grid[nbr.row][nbr.col]==j+2) break; &#125; here=new Position(nbr.row,nbr.col); &#125; System.out.println(\"最短路线为：\"); for(int j=0;j&lt;pathLen-1;j++)&#123; System.out.println(\"点\"+(j+1)+\"位置: 行-\"+path[j].row+\" 列-\"+path[j].col); &#125; System.out.println(\"布线长度为：\"+pathLen); return true; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(\"请输入方格阵列大小：\"); String s1=sc.nextLine(); Integer size=Integer.parseInt(s1); System.out.println(\"请输入起始点的行和列，用空格隔开：\"); String s2=sc.nextLine(); String[] s3=s2.split(\" \"); int startRow=Integer.parseInt(s3[0]); int startCol=Integer.parseInt(s3[1]); Position start=new Position(startRow,startCol); System.out.println(\"请输入结束点的行和列，用空格隔开：\"); String s4=sc.nextLine(); String[] s5=s4.split(\" \"); int finishRow=Integer.parseInt(s5[0]); int finishCol=Integer.parseInt(s5[1]); Position finish=new Position(finishRow,finishCol); int[][] grid=new int[size+2][size+2]; System.out.println(\"请输入方格阵列：\"); for(int i=1;i&lt;=size;i++)&#123; String str=sc.nextLine(); String[] strs=str.split(\" \"); for(int j=0;j&lt;strs.length;j++)&#123; grid[i][j+1]=Integer.parseInt(strs[j]); &#125; &#125; WireRouter w=new WireRouter(grid,size,start,finish); w.findPath(); &#125; &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"回溯法---0-1背包问题","date":"2017-12-30T09:04:17.000Z","path":"2017/12/30/sf010/","text":"0-1背包问题问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度计算上界时间:$$O(n)$$ 最坏情况有:$$O(2^n)$$个右儿子节点需计算上界。所以回溯算法Backtrack所需时间:$$O(n2^n)$$ java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 0-1背包问题--回溯法 * */ public class Knapsack &#123; public static class Element implements Comparable&#123; int id;//物品编号 double d; public Element(int id,double d)&#123; this.id=id; this.d=d; &#125; @Override public int compareTo(Object x) &#123; double xd=((Element)x).d;//递减顺序排列 if(d&lt;xd) return -1; if(d==xd) return 0; return 1; &#125; &#125; double c;//背包容量 int n;//物品数 double[] w;//物品重量数组 double[] p;//物品价值数组 double cw;//当前重量 double cp;//当前价值 double bestp;//最优价值 int[] x;//当前装入背包顺序 int[] bestx;//最优装入背包顺序 Element[] q;//q为单位重量价值数组 public double knapsack(double[] pp,double[] ww,double cc)&#123; //初始化 c=cc; n=pp.length-1; cw=0; cp=0; bestp=0; x=new int[n+1]; bestx=new int[n+1]; //q为单位重量价值数组 q=new Element[n+1]; for(int i=0;i&lt;=n;i++)&#123; q[i]=new Element(i,pp[i]/ww[i]); &#125; //将个物品依单位重量价值从大到小排列 java.util.Arrays.sort(q); p=new double[n+1]; w=new double[n+1]; for(int i=1;i&lt;=n;i++)&#123; p[i]=pp[q[i].id]; w[i]=ww[q[i].id]; &#125; backtrack(1); return bestp; &#125; public void backtrack(int i)&#123; if(i&gt;n)&#123;//到达叶子节点 bestp=cp; for(int j=1;j&lt;=n;j++)&#123;//保存最优值对应的包的编号 bestx[j]=x[j]; &#125; return; &#125; if(cw+w[i]&lt;=c)&#123;//左子树 x[i]=1; cw+=w[i]; cp+=p[i]; backtrack(i+1); cw-=w[i];//恢复现场 cp-=p[i]; &#125; if(bound(i+1)&gt;bestp)&#123; x[i]=0; backtrack(i+1); &#125; &#125; public double bound(int i)&#123;//上界函数 double cleft=c-cw; double bound=cp; while(i&lt;=n&amp;&amp;w[i]&lt;=cleft)&#123; cleft-=w[i]; bound+=p[i]; i++; &#125; if(i&lt;=n)&#123; bound+=p[i]*cleft/w[i]; &#125; return bound; &#125; public static void main(String[] args) &#123; double[] weight=&#123;0,71,34,82,23,1,88,12,57,10,68,5,33,37,69,98,24,26,83,16,26,18,43,52,71,22,65,68,8,40,40,24,72,16,34,10,19,28,13,34,98,29,31,79,33,60,74,44,56,54,17&#125;; double[] price=&#123;0,26,59,30,19,66,85,94,8,3,44,5,1,41,82,76,1,12,81,73,32,74,54,62,41,19,10,65,53,56,53,70,66,58,22,72,33,96,88,68,45,44,61,78,78,6,66,11,59,83,48&#125;; double cc=300; //double[] weight=&#123;0,7,3,4,5&#125;; //double[] price=&#123;0,42,12,40,25&#125;; //double cc=10; Knapsack k=new Knapsack(); double best=k.knapsack(price,weight,cc); System.out.println(\"最优值：\"+best); System.out.println(\"选中的物品编号分别是：\"); for(int i=1;i&lt;k.bestx.length;i++)&#123; if(k.bestx[i]==1)&#123; System.out.print(k.q[i].id+\" \"); &#125; &#125; &#125; &#125; /* 输出结果：最优值：1063.0选中的物品编号分别是：5 7 35 38 28 19 21 33 37 31 50 44 39 42 2 11 */","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"回溯法---符号三角形","date":"2017-12-30T05:07:21.000Z","path":"2017/12/30/sf009/","text":"回溯法 问题解空间 深度优先遍历 深度搜索至任意一个节点，若包括问题解，继续按深度优先策略搜索;如果不包含问题解，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯。 减枝函数 符号三角形问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度计算可行性约束(符号个数)需要时间:$$O(n)$$最坏情况(n个符号排列)有:$$O(2^n)$$个节点需要计算可行性约束，故回溯算法 Backtrack 所需计算时间: $$O(n2^n)$$ java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Triangles &#123; private int n;// 第一行符号个数 private int half;// n*(n+1)/4 private int count;//当前\"+\"号个数 private int[][] p;//符号三角形矩阵 private long sum;//已找到符号三角形数 private void Backtrack(int t) &#123; if((count&gt;half)||(t*(t-1)/2-count&gt;half)) return;// 控制\"+\"\"-\"个数相等 if(t&gt;n) sum++; else &#123; for (int i = 0; i &lt; 2; i++) &#123;// 1 为\"+\" , 0为\"-\" p[1][t] = i; count += i; for (int j = 2; j &lt;= t; j++) &#123; p[j][t-j+1] = p[j-1][t-j+1]^p[j-1][t-j+2]; count += p[j][t-j+1]; &#125; Backtrack(t+1); for (int j = 2; j &lt;= t; j++) &#123; count -= p[j][t-j+1]; &#125; count -= i; &#125; &#125; &#125; private static long Compute(int n) &#123; Triangles X = new Triangles(); X.n = n; X.count = 0; X.half = n*(n+1)/2; if (X.half%2 == 1)return 0;// 符号数为奇数 X.half = X.half/2; X.sum = 0; int[][] p = new int[n+1][n+1]; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= n; j++) &#123; p[i][j] = 0; &#125; X.p = p; X.Backtrack(1); return X.sum; &#125; public static void main(String[] args) &#123; int m = 3; long n = Compute(m); System.out.println(\"第一行符号数 n=\"+m+\"时，有\"+n+\"个符号三角形\"); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"贪心算法---最小生成树","date":"2017-12-30T03:17:39.000Z","path":"2017/12/30/sf008/","text":"最小生成树问题描述 计算机算法设计与分析(第四版)，王晓东 最小生成树性质 假设 N = (V,{ E })是一个连通网，U 是顶点集 V 的一个非空子集。若(u , v)是一条具有最小权值(代价)的边，其中u∈U， v∈V - U，则必存在一棵包含边(u，v)的最小生成树。 反证: 假设网N的任何一棵最小生成树都不包含(u，v)。设T是连通网上的一棵最小生成树，当将边(u，v)加入到T中时，由生成树的定义，T中必存在一条包含(u，v)的回路。另一方面，由于T是生成树，则在T上必存在另一条边(u’，v’)，其中u’∈U，v’∈V - U，且u和u’之间，v和v’之间均有路径相通。删去边(u’，v’)，便可消除上述回路，同时得到另一棵生成树T’。因为(u，v)的代价不高于(u’，v’)，则T’的代价亦不高于T，T’是包含(u，v)的一棵最小生成树，和假设矛盾。 时间复杂度 略 Prim(普里姆算法) 算法选取满足条件 i∈S，j∈V-S，且 c[i][j] 最小的边，将顶点 j 添加到 S 中。这个过程一直进行到 S=V 时为止。在这个过程中选取到的所有边恰好构成G的一棵最小生成树T。 java 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MinSpanTree &#123; public static void Prim(int n, int[][] c) &#123; int[] lowcost= new int[n]; int[] closest= new int[n]; boolean[] s= new boolean[n]; s[1] = true; // 初始化lowcost[i](到顶点i最小代价)，closest[i](i的连接点) for (int i = 2; i &lt; n; i++) &#123; lowcost[i] = c[1][i]; closest[i] = 1; s[i] = false; &#125; for (int i = 1; i &lt; n-1; i++) &#123; int min = Integer.MAX_VALUE; int j = 1; for (int k = 2; k &lt; n; k++) &#123; if ((lowcost[k] &lt; min)&amp;&amp;(!s[k])) &#123; min = lowcost[k];j=k; &#125; &#125; System.out.println(j); s[j] = true; //将第j个顶点纳入S for (int k = 2; k &lt; n; k++) &#123; if ((c[j][k] &lt; lowcost[k])&amp;&amp;(!s[k])) &#123; lowcost[k] = c[j][k];closest[k] = j; &#125; &#125; System.out.println(closest[j]+\"&lt;--&gt;\"+j); &#125; &#125; public static void main(String[] args) &#123; int MAX_WEIGHT =Integer.MAX_VALUE; // matri[i][j] = a 表示顶点i到j的权值为a int[][] matrix = &#123; &#123;MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT&#125;, &#123;MAX_WEIGHT,0,6,1,5,MAX_WEIGHT,MAX_WEIGHT&#125;, &#123;MAX_WEIGHT,6,0,5,MAX_WEIGHT,3,MAX_WEIGHT&#125;, &#123;MAX_WEIGHT,1,5,0,5,6,4&#125;, &#123;MAX_WEIGHT,5,MAX_WEIGHT,5,0,MAX_WEIGHT,2&#125;, &#123;MAX_WEIGHT,MAX_WEIGHT,3,6,MAX_WEIGHT,0,6&#125;, &#123;MAX_WEIGHT,MAX_WEIGHT,MAX_WEIGHT,4,2,6,0&#125; &#125;; int n = matrix.length; Prim(n, matrix); &#125;&#125; Kruskal 算法首先将G的n个顶点看成n个孤立的连通分支。将所有的边按权从小到大排序。然后从第一条边开始，依边权递增的顺序查看每一条边，并按下述方法连接2个不同的连通分支：当查看到第k条边(v,w)时，如果端点v和w分别是当前2个不同的连通分支T1和T2中的顶点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；如果端点v和w在当前的同一个连通分支中，就直接再查看第k+1条边。这个过程一直进行到只剩下一个连通分支时为止。","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"贪心算法---单源最短路径","date":"2017-12-30T02:34:34.000Z","path":"2017/12/30/sf007/","text":"单源最短路径问题描述 计算机算法设计与分析(第四版)，王晓东 给定一个带权有向图 G=（V,E），其中每条边的权是一个非负实数。另外，还给定V中的一个顶点，称为源。现在要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。 其基本思想是，设置顶点集合S并不断地作贪心选择来扩充这个集合。每一次加入S 的点都是距离S之外最短的点。 贪心选择性质该算法所作出的贪心选择是从V-S中选择具有最短特殊路径的顶点u，从而确定从源S到u的最短路径长度为dist[u]. 反证: dist[u]表示从已挑选集合源S到u的最短路径长度，假设有一点x不属于S使得从源经过x再到u的距离比dist[u]更短。d(v,x)表示从S中源点v到x的距离，显然:$$dist[x] &lt;= d(v,x)$$由假设可得:$$d(v,x) + d(x,u) = d(v,u) &lt; dist[u] $$因为$$d(x,u) &gt;= 0$$推出$$dist[x]&lt;dist[u]$$这就表明x就是距离源外最短的点，也就是原来的u，而不是假设的 中间点，故此为矛盾，证毕。 最优子结构性质java 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Dijkstra &#123; static float maxint = Float.MAX_VALUE-1000; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stubfloat c[ ][ ] =&#123;&#123;maxint,maxint,maxint,maxint,maxint,maxint&#125;,&#123;maxint,maxint,10,maxint,30,100&#125;,&#123;maxint,10,maxint,50,maxint,maxint&#125;,&#123;maxint,maxint,50,maxint,20,10&#125;,&#123;maxint,maxint,maxint,20,maxint,60&#125;,&#123;maxint,100,maxint,10,60,maxint&#125;&#125;; float dist[ ] = new float [7]; int prev[ ] = new int [7]; int n = 5; int v = 1; dijkstra(n, v, dist, prev, c); &#125; /** * @param n n个顶点 * @param v 顶点v为源点 * @param dist dist[i]记录源点到i顶点最短特殊路径长度 * @param prev prev[i]记录源点到i顶点最短路径上，i的前一个顶点 * @param c c[i][j]表示边(i,j)的权 */ public static void dijkstra(int n, int v, float dist[ ],int prev[ ],float c[ ][ ]) &#123; boolean[ ] s = new boolean[n + 1]; for (int i = 1; i &lt;= n ; i++) &#123; dist[i] = c[v][i]; s[i] = false; if(dist[i] == maxint) prev[i] = 0; else prev[i] = v; &#125; dist[v] = 0; s[v] = true; for (int i = 1; i &lt; n; i++) &#123; float temp = maxint; int u =v; for (int j = 1; j &lt; n; j++) &#123; if ( (!s[j]) &amp;&amp; (dist[j] &lt; temp) ) &#123; u = j; temp = dist[j]; &#125; &#125; s[u] = true; for (int j = 1; j &lt;= n; j++) &#123; if ((!s[j]) &amp;&amp; (c[u][j] &lt; maxint) ) &#123; float newdist = dist[u] + c[u][j]; if(newdist &lt; dist[j] ) &#123; dist[j] = newdist; prev[j] = u; &#125; &#125; &#125; &#125; for(int i=2;i&lt;=5;i++)&#123; System.out.println(\"prev[\"+i+\"] = \"+prev[i]); &#125; for(int i=2;i&lt;=5;i++)&#123; System.out.println(\"dist[\"+i+\"] = \"+dist[i]); &#125; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"贪心算法---活动安排问题","date":"2017-12-28T11:46:02.000Z","path":"2017/12/28/sf006/","text":"活动安排问题问题描述 计算机算法设计与分析(第四版)，王晓东 贪心选择性质 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择. 动态规划: 每步所做的选择往往依赖于相关子问题的解。只有解除子问题的解才能做出选择。_自底向上_ 贪心算法: 仅在当前状态下做出最好选择，即局部最优选择。_自顶向下_ 对于一个具体问题，要确定它是否具有 贪心选择性质,必须证明每一步所作的贪心选择最终导致问题的整体最优解。 活动安排问题贪的是 活动最早完成时间 ，直观上为未安排活动留下更多时间。 最优子结构性质若集合 A 是所有活动集 E 中包含活动 1 的一个最优解，则集合 A’ = A - {1} 也是对于 E’ (以活动1结束时间为起始时间)的一个最优解。 反证: 若能找到 E’ 的一个解 B’ ,它包含比 A’ 更多的活动，则将活动1加入到 B’ 将产生 E 的一个解 B ，它包含比 A 更多的活动，这与 A 的最优性矛盾。 时间复杂度算法排序起始时间: $$O(nlogn)$$算法安排活动只需: $$\\theta(n)$$ java 代码1234567891011121314151617181920212223242526272829303132333435public class GreedySelector &#123; /** * * @param s 活动开始时间 * @param f 活动结束时间 * @param A 是否选择活动 * @return 已选择活动数 */ public static int greedyselector(int[] s,int[] f,boolean[] A) &#123; int n = s.length - 1; int count = 1; A[1] = true; int j = 1; System.out.print(\"start:(1)\"+ s[1] + \"-&gt;\" + f[1] + \"-&gt;\"); for(int i=2;i&lt;=n;i++) &#123; if (s[i] &gt;= f[j]) &#123; A[i] = true; j=i;count++; System.out.print(\"(\"+i+\")\"+ s[i] + \"-&gt;\" + f[i] + \"-&gt;\"); &#125;else &#123; A[i] = false; &#125; &#125; System.out.print(\"end\\n\"); return count; &#125; public static void main(String[] args) &#123; int s[]=&#123;1,3,0,5,3,5,6,8,8,2,12&#125;; int f[]=&#123;4,5,6,7,8,9,10,11,12,13,14&#125;; boolean [] a=new boolean[11]; int c = greedyselector(s, f, a); System.out.println(\"共有\"+c+\"个活动被安排。\"); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"动态规划---最长公共子序列","date":"2017-12-26T11:33:31.000Z","path":"2017/12/26/sf005/","text":"最长公共子序列问题描述 计算机算法设计与分析(第四版)，王晓东 最优子结构性质设序列 X={x1,x2,…,xm} 和 Y={y1,y2,…,yn} 的最长公共子序列为 Z={z1,z2,…,zk} ，则 若xm=yn，则zk=xm=yn，且Z k-1是xm-1和yn-1的最长公共子序列。 若xm≠yn且zk≠xm，则Z是xm-1和Y的最长公共子序列。 若xm≠yn且zk≠yn，则Z是X和yn-1的最长公共子序列。 两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有 最优子结构性质。 子问题递归结构用c[i][j]记录序列Xi和Yj的最长公共子序列的长度。其中，$$ Xi={x1,x2,…,xi};Yj={y1,y2,…,yj}$$当 i=0 或 j=0 时，空序列是 Xi 和 Yj 的最长公共子序列。故此时C[i][j]=0。其他情况下，由最优子结构性质可建立递归关系如下: java 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package dtgh;public class LongestCommonSub &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str1 = \"ABCBDAB\"; String str2 = \"BDCABA\"; //计算lcs递归矩阵 int[][] re = longestCommonSubsequence(str1, str2); //打印矩阵 for (int i = 0; i &lt;= str1.length(); i++) &#123; for (int j = 0; j &lt;= str2.length(); j++) &#123; System.out.print(re[i][j] + \" \"); &#125; System.out.println(); &#125; System.out.println(); System.out.println(); //输出LCS print(re, str1, str2, str1.length(), str2.length()); &#125; // 假如返回两个字符串的最长公共子序列的长度 public static int[][] longestCommonSubsequence(String str1, String str2) &#123; int[][] matrix = new int[str1.length() + 1][str2.length() + 1];//建立二维矩阵 // 初始化边界条件 for (int i = 0; i &lt;= str1.length(); i++) &#123; matrix[i][0] = 0;//每行第一列置零 &#125; for (int j = 0; j &lt;= str2.length(); j++) &#123; matrix[0][j] = 0;//每列第一行置零 &#125; // 填充矩阵 for (int i = 1; i &lt;= str1.length(); i++) &#123; for (int j = 1; j &lt;= str2.length(); j++) &#123; if (str1.charAt(i - 1) == str2.charAt(j - 1)) &#123; matrix[i][j] = matrix[i - 1][j - 1] + 1; &#125; else &#123; matrix[i][j] = (matrix[i - 1][j] &gt;= matrix[i][j - 1] ? matrix[i - 1][j] : matrix[i][j - 1]); &#125; &#125; &#125; return matrix; &#125; //根据矩阵输出LCS public static void print(int[][] opt, String X, String Y, int i, int j) &#123; if (i == 0 || j == 0) &#123; return; &#125; if (X.charAt(i - 1) == Y.charAt(j - 1)) &#123; print(opt, X, Y, i - 1, j - 1); System.out.print(X.charAt(i - 1)); &#125; else if (opt[i - 1][j] &gt;= opt[i][j]) &#123; print(opt, X, Y, i - 1, j); &#125; else &#123; print(opt, X, Y, i, j - 1); &#125; &#125; &#125; python代码12345678910111213141516171819202122232425262728293031323334353637383940def lcs(a,b): lena=len(a) lenb=len(b) c=[[0 for i in range(lenb+1)] for j in range(lena+1)] flag=[[0 for i in range(lenb+1)] for j in range(lena+1)] for i in range(lena): for j in range(lenb): if a[i]==b[j]: c[i+1][j+1]=c[i][j]+1 flag[i+1][j+1]='ok' elif c[i+1][j]&gt;c[i][j+1]: c[i+1][j+1]=c[i+1][j] flag[i+1][j+1]='left' else: c[i+1][j+1]=c[i][j+1] flag[i+1][j+1]='up' return c,flag def printLcs(flag,a,i,j): if i==0 or j==0: return if flag[i][j]=='ok': printLcs(flag,a,i-1,j-1) print(a[i-1],end='') elif flag[i][j]=='left': printLcs(flag,a,i,j-1) else: printLcs(flag,a,i-1,j) a='ABCBDAB' b='BDCABA' c,flag=lcs(a,b) for i in c: print(i) print('') for j in flag: print(j) print('') printLcs(flag,a,len(a),len(b)) print('')","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"动态规划---矩阵连乘","date":"2017-12-23T14:08:08.000Z","path":"2017/12/23/sf004/","text":"矩阵连乘问题描述 计算机算法设计与分析(第四版)，王晓东 动态规划基本要素最优子结构 当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。 计算 A[1:n] 的最优次序，其所包含的矩阵子链 A[1:k] 和 A[k+1:n] 的次序也是最优的。即该问题具有 最优子结构性质。 反证法证明：如果有一个计算 A[1:k] 的次序需要的计算量更少，则用此次序替换原来计算 A[1:k] 次序，得到的计算 A[1:n] 的计算量将比按最优次序计算量更少，这与前提矛盾。计算最优值:因为n个元素对2求组合数最多为 n(n-1)/2，另外还有 n 个单矩阵的子问题,因此，不同子问题的个数最多只有: 重叠子问题 区别于分治法,动态规划可以解决有些问题用分治法计算存在的大量重复计算。 最优解递归关系将矩阵连乘积 $$ A_{i}A_{i-1}A_{i-2}A_{i-3}…. $$简记为 $$A[i:j],i≤j$$设计算 $$A[i:j]，1≤i≤j≤n$$ 所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n].则 m[i][j] 可递归定义为: 算法复杂度分析算法MatrixChain的主要计算量取决于算法中的3重循环。循环体内的计算量为O(1)，而3重循环的总次数为O(n^3)。因此算法的计算时间上界为O(n^3)。算法所占用的空间显然为O(n^2)。 java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MatrixMul &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub /** *p[i]的含义有两层指的是： *1. 第i个矩阵的列 *2. 第i+1个矩阵的行 **/ int []p = &#123;30,35,15,5,10,20,25&#125;; int len = p.length; int [][]m = new int [len+1][len+1];//记录连乘次数 int [][]s = new int [len+1][len+1];//记录最佳分割位置 MatrixChain(p,len,m,s); System.out.println(\"矩阵计算量最小次数矩阵m[i][j]:\"); PrintMatrixMul(m,p.length); System.out.println(\"相对于M矩阵的最优断开位置矩阵s[i][j]:\"); PrintMatrixMul(s,p.length); System.out.println(\"乘法的最优次序：\"); traceback(1,len-1,s); &#125; // 打印数组 private static void PrintMatrixMul(int[][] m,int n) &#123; for(int i = 1;i&lt;=n-1;i++)&#123; for(int j =1;j&lt;=n-1;j++)&#123; System.out.print(m[i][j]+\"\\t\"); if(j % (n-1) ==0)System.out.print(\"\\n\"); &#125; &#125; &#125; /** * * @param p 输入参数&#123;p0，p1，p2，...&#125; * @param n * @param m 最优值数组 * @param s 最优断开位置数组 */ public static void MatrixChain(int[] p, int n, int [][]m, int [][]s) &#123; for (int i = 1; i &lt;= n; i++) &#123;m[i][i] = 0;&#125;// 初始化单个矩阵连乘 for (int r = 2; r &lt;= n; r++) &#123; for (int i = 1; i &lt;= n-r; i++) &#123; int j = i+r-1; m[i][j] = m[i+1][j]+p[i-1]*p[i]*p[j]; s[i][j] = i; for (int k = i+1; k &lt; j; k++) &#123; int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if (t &lt; m[i][j]) &#123; m[i][j] = t;s[i][j] = k; &#125; &#125; &#125; &#125; &#125; /** * * @param i * @param j * @param s */ private static void traceback(int i, int j, int[][] s) &#123; if (i == j) &#123; System.out.print(\"A\"+i); &#125;else if(i+1 == j )&#123; System.out.print(\" (A\"+i+\" * \"+\" A\"+j+\") \"); &#125;else &#123; System.out.print(\" (\"); traceback(i, s[i][j], s); traceback(s[i][j]+1,j, s); System.out.print(\") \"); &#125; &#125;&#125; python代码12345678910111213141516171819202122232425262728293031323334353637class Matrix: def __init__(self, row_num=0, col_num=0, matrix=None): if matrix != None: self.row_num = len(matrix) self.col_num = len(matrix[0]) else: self.row_num = row_num self.col_num = col_num self.matrix = matrix def matrix_chain(matrixs): matrix_num = len(matrixs) count = [[0 for j in range(matrix_num)] for i in range(matrix_num)] flag = [[0 for j in range(matrix_num)] for i in range(matrix_num)] for r in range(1, matrix_num + 1): for i in range(matrix_num - r): j = i + interval count[i][j] = count[i][i] + count[i + 1][j] + matrixs[i].row_num * matrixs[i + 1].row_num * matrixs[j].col_num flag[i][j] = i for k in range(i + 1, j): temp = count[i][k] + count[k + 1][j] + matrixs[i].row_num * matrixs[k + 1].row_num * matrixs[j].col_num if temp &lt; count[i][j]: count[i][j] = temp flag[i][j] = k traceback(0, matrix_num - 1, flag) return count[0][matrix_num - 1] def traceback(i, j, flag): if i == j: return if j - i &gt; 1: print(str(i + 1) + '~' + str(j + 1), end=': ') print(str(i + 1) + \":\" + str(flag[i][j] + 1), end=',') print(str(flag[i][j] + 2) + \":\" + str(j + 1)) traceback(i, flag[i][j], flag) traceback(flag[i][j] + 1, j, flag) matrixs = [Matrix(30, 35), Matrix(35, 15), Matrix(15, 5), Matrix(5, 10), Matrix(10, 20), Matrix(20, 25)] result = matrix_chain(matrixs) print(result)","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"递归与分治---快速排序","date":"2017-12-22T11:33:07.000Z","path":"2017/12/22/sf003/","text":"快速排序问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度分析最坏情况:每次划分的基准刚好为中值。 $$T(n)=2*T(n/2)+n$$ 其平均算法复杂度为: $$O(nlogn)$$ java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.Random;public class QuickSort &#123; public static void main (String[] args) &#123; int[] array = &#123;6,7,4,5,2,3,1&#125;; int[] arr = QuickSort.Quicksort(array, 0, array.length-1); System.out.println(\"最终结果\"); for (int i : arr) &#123; System.out.print(i + \" \"); &#125; System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); System.out.println(\"随机选择策略：\"); int[] array2 = &#123;6,7,4,5,2,3,1&#125;; int[] arr2 = QuickSort.RandomizedQuicksort(array2, 0, array.length-1); System.out.println(\"最终结果\"); for (int i : arr2) &#123; System.out.print(i + \" \"); &#125; &#125; public static int Partition(int[] arr, int low, int high) &#123; int i = low,j = high+1; int base = arr[low];// 基准元素 while(true) &#123; while(arr[++i] &lt; base &amp;&amp; i &lt; high) &#123; System.out.println(\"从左往右找比\" + base + \"大的，左指针变动：--&gt;\" + i); &#125; while(arr[--j] &gt; base) &#123; System.out.println(\"从右往左找比\" + base + \"小的，右指针变动：--&gt;\" + j); &#125; if(i &gt;= j) break; Swap(arr, i, j); &#125; arr[low] = arr[j]; arr[j] = base; System.out.println(\"对调\" + arr[low] + \"与\" + arr[j] + \",得到\"); for (int k : arr) &#123; System.out.print(k + \" \"); &#125; System.out.println(); return j; &#125; private static int[] Quicksort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int division = Partition(arr, low, high); Quicksort (arr, low, division - 1); Quicksort (arr, division + 1 , high); &#125; return arr; &#125; public static void Swap(int[] array, int a, int b) &#123; if(a != b) &#123; int temp = array[a]; array[a] = array[b]; array[b] = temp; System.out.println(\"对调\" + array[a] + \"与\" + array[b] + \",得到\"); for (int i : array) &#123; System.out.print(i + \" \"); &#125; System.out.println(); &#125; &#125; private static int[] RandomizedQuicksort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123; int q = RandomizedPartition(arr, low, high); RandomizedQuicksort (arr, low, q - 1); RandomizedQuicksort (arr, q + 1 , high); &#125; return arr; &#125; public static int RandomizedPartition(int[] arr, int low, int high) &#123; Random random = new Random(System.currentTimeMillis()); int i = random.nextInt(high-low)+low; Swap(arr, i, low); return Partition(arr, low, high); &#125;&#125; python代码12345678910111213141516171819202122232425def QuickSort(arr,firstIndex,lastIndex): if firstIndex&lt;lastIndex: divIndex=Partition(arr,firstIndex,lastIndex) QuickSort(arr,firstIndex,divIndex) QuickSort(arr,divIndex+1,lastIndex) else: returndef Partition(arr,firstIndex,lastIndex): i=firstIndex-1 for j in range(firstIndex,lastIndex): if arr[j]&lt;=arr[lastIndex]: i=i+1 arr[i],arr[j]=arr[j],arr[i] arr[i+1],arr[lastIndex]=arr[lastIndex],arr[i+1] return iarr=[1,4,7,1,5,5,3,85,34,75,23,75,2,0]print(\"initial array:\\n\",arr)QuickSort(arr,0,len(arr)-1)print(\"result array:\\n\",arr)","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"递归与分治---合并排序","date":"2017-12-22T01:55:32.000Z","path":"2017/12/22/sf002/","text":"合并排序 (归并排序)问题描述 计算机算法设计与分析(第四版)，王晓东 时间复杂度分析 java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MergeSort &#123; public static void main (String[] args) &#123; int[] array = &#123;1,3,4,6,2,7,5&#125;; int[] arr = new MergeSort().sort(array); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]); &#125; &#125; public int[] sort(int[] arrs)&#123; if(arrs.length &lt; 2)&#123; return arrs; &#125; int middle = arrs.length % 2 == 0 ? arrs.length / 2 : (arrs.length - 1) / 2; int[] left = Arrays.copyOfRange(arrs, 0, middle); int[] right = Arrays.copyOfRange(arrs, middle, arrs.length); int[] lres = sort(left); // 递归 int[] rres = sort(right); return merge(lres, rres); &#125; private int[] merge(int[] lres, int[] rres) &#123; // 合并左右数组 int[] res = new int[lres.length + rres.length]; int l = 0; int r = 0; int c = 0; while(l &lt; lres.length &amp;&amp; r &lt; rres.length)&#123; if(lres[l] &lt; rres[r])&#123; res[c++] = lres[l++]; &#125; else &#123; res[c++] = rres[r++]; &#125; &#125; if(l == lres.length)&#123; while(r &lt; rres.length)&#123; res[c++] = rres[r++]; &#125; return res; &#125; if(r == rres.length)&#123; while(l &lt; lres.length)&#123; res[c++] = lres[l++]; &#125; return res; &#125; return res; &#125;&#125; python 代码一般方法123456789101112131415161718192021222324252627282930def merge_sort(seq): if len(seq)== 1: return seq else: middle = len(seq)//2 left = merge_sort(seq[:middle]) right = merge_sort(seq[middle:]) i = 0 // left j = 0 // right k = 0 // all while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: seq[k] = left[i] i += 1 k += 1 else: seq[k] = right[j] j += 1 k += 1 // remain of left or right remain = left if i&lt;j else right r = i if remain == left else j while r&lt;len(remain): seq[k] = remain[r] r += 1 k += 1 return seq pop123456789101112131415161718def merge_sort_w(seq): if len(seq) &lt;= 1: return seq def merge(left,right): merged = [] while left and right: merged.append(left.pop(0) if left[0] &lt;= right[0] else right.pop(0)) // remain while left: merged.append(left.pop(0)) while right: merged.append(right.pop(0)) return merged middle = int(len(seq) / 2) left = merge_sort_w(seq[:middle]) right = merge_sort_w(seq[middle:]) return merge(left,right) heapq12345678910from heapq import mergedef merge_sort_h(seq): if len(seq) &lt;= 1: return seq else: middle = len(seq)//2 left = merge_sort_h(seq[:middle]) right = merge_sort_h(seq[middle:]) return list(merge(left, right)) # heapq.merge","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"递归与分治---棋盘覆盖","date":"2017-12-20T01:38:17.000Z","path":"2017/12/20/sf001/","text":"棋盘覆盖问题描述 计算机算法设计与分析(第四版)，王晓东 在一个2^k * 2^k个方格组成的棋盘中,若有一个方格与其他方格不同,则称该方格为一特殊方格,且称该棋盘为一个特殊棋盘。显然特殊方格在棋盘上出现的位置有4^k种情形. 因而对任何k ≥ 0,有 4^k 种不同的特殊棋盘。下图所示的特殊棋盘为 k=2 时 16 个特殊棋盘中的一个。 在棋盘覆盖问题中，要用下图中 4 中不同形态的 L 型骨牌覆盖一个给定的特殊棋牌上除特殊方格以外的所有方格，且任何 2 个 L 型骨牌不得重叠覆盖。易知，在任何一个 2^k * 2^k 的棋盘中，用到的 L 型骨牌个数恰为 (4^k-1)/3 。 求解棋盘问题，可利用分治的策略。当 k&gt;0 时，将 2^k 2^k 棋盘分割为 4 个 2^(k-1) 2^(k-1) 子棋盘，如下图所示。 特殊方格必位于 4 个较小子棋盘之一中，其余 3 个子棋盘中无特殊方格。用一个 L 型骨牌覆盖这 3 个较小的棋盘的 汇合处 ，如图所示，将这 3 个无特殊方格的子棋盘转化为 特殊棋盘，从而将原问题化为 4 个较小规模的棋盘覆盖问题。递归的使用 这种分割，直至棋盘简化为 1x1 棋盘。 时间复杂度分析 java 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package dgfz;import java.awt.Color;import java.awt.Container;import java.awt.Graphics;import javax.swing.JFrame;public class qpfg &#123; public static void main (String[] args) &#123; new DrawPanel(); &#125;&#125;class DrawPanel extends JFrame &#123; //设定特殊棋子位置坐标 private int dx = 2; private int dy = 1; //棋盘大小 private int dsize = 8; // 2^k * 2^k //小方块边长 private static final int c = 50; // 窗口大小 int a = dsize*c+50; // L型骨牌号 private static int tile = 0; private Graphics jp; /** * DrawPanel构造方法 */ public DrawPanel() &#123; Container p = getContentPane(); setBounds(100, 100, a+100, a+100); setVisible(true); p.setBackground(Color.WHITE); setLayout(null); setResizable(false); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); try &#123; // 等待时间 Thread.sleep(500); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; jp = this.getGraphics(); //绘制 painPanel(jp); &#125;public void painPanel(Graphics g) &#123; /** * 画棋盘 * */ try &#123; //画格子 g.setColor(Color.RED); g.drawRect(c, c, dsize*c, dsize*c); for (int i = 1; i &lt; dsize; i++) &#123; g.drawLine(c + (i * c), c, c + (i * c), a); g.drawLine(c,c + (i * c), a, c + (i * c)); &#125; //设定特殊棋子位置 g.setColor(Color.BLACK); g.fillRect(c*dx+5, c*dy+5, c-10, c-10); g.setColor(Color.RED); Thread.sleep(500); chess(1, 1, dx, dy, dsize, g); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public void chess(int tr, int tc, int dr, int dc, int size, Graphics g) &#123; /* * 棋盘分割 * tr,tc:棋盘左上角行列号 * dr,dc:特殊方格行列号 * size： size = 8，就是棋盘大小8 x 8 * */ try &#123; if (size == 1) return ; String tt = String.valueOf(tile++); int s = size / 2; //左上 if(dr &lt; tr + s &amp;&amp; dc &lt; tc + s) // 特殊方格在此棋盘中 chess(tr, tc, dr, dc, s, g); else &#123; // 特殊方格不在此棋盘中，用L型骨牌号 tt 填入右下角 g.drawString(tt, (tr + s - 1)*c+c/2, (tc + s - 1)*c+c/2); System.out.println((tr+s-1)+\",\"+(tc + s - 1)+\"---&gt;\"+tt); chess(tr, tc, tr+s-1, tc+s -1, s, g); &#125; //右上 if(dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) chess(tr, tc + s, dr, dc, s, g); else &#123; g.drawString(tt, (tr + s - 1)*c+c/2, (tc + s)*c+c/2); System.out.println((tr+s-1)+\",\"+(tc + s)+\"---&gt;\"+tt); chess(tr, tc + s, tr+s-1, tc+s , s, g); &#125; //左下 if(dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) chess(tr + s, tc, dr, dc, s, g); else &#123; g.drawString(tt, (tr + s )*c+c/2, (tc + s - 1)*c+c/2); System.out.println((tr+s)+\",\"+(tc + s - 1)+\"---&gt;\"+tt); chess(tr +s , tc, tr+s, tc+s -1, s, g); &#125; //右下 if(dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) chess(tr + s, tc + s, dr, dc, s, g); else &#123; g.drawString(tt, (tr + s)*c+c/2, (tc + s)*c+c/2); System.out.println((tr+s)+\",\"+(tc + s)+\"---&gt;\"+tt); chess(tr + s, tc + s, tr+s, tc+s , s, g); &#125; Thread.sleep (500 ) ; &#125; catch (InterruptedException ie)&#123; &#125; &#125;&#125; python 代码 12345678910111213141516171819202122232425262728293031323334353637383940// tr左上角行号，tc左上角列号。dr特殊方格行号，dc特殊方格列号def chessboard(board, size, tr, tc, dr, dc): if size &lt;= 1: return global tile tile += 1 current_tile = tile size //= 2 if dr &lt; tr + size and dc &lt; tc + size: chessboard(board, size, tr, tc, dr, dc) else: board[tr + size - 1][tc + size - 1] = current_tile chessboard(board, size, tr, tc, tr + size - 1, tc + size - 1) if dr &gt;= tr + size and dc &lt; tc + size: chessboard(board, size, tr + size, tc, dr, dc) else: board[tr + size][tc + size - 1] = current_tile chessboard(board, size, tr + size, tc, tr + size, tc + size - 1) if dr &lt; tr + size and dc &gt;= tc + size: chessboard(board, size, tr, tc + size, dr, dc) else: board[tr + size - 1][tc + size] = current_tile chessboard(board, size, tr, tc + size, tr + size - 1, tc + size) if dr &gt;= tr + size and dc &gt;= tc + size: chessboard(board, size, tr + size, tc + size, dr, dc) else: board[tr + size][tc + size] = current_tile chessboard(board, size, tr + size, tc + size, tr + size, tc + size)tile = 0chessboard_size = 4board = [[0 for x in range(chessboard_size)] for y in range(chessboard_size)]chessboard(board, chessboard_size, 0, 0, 1, 0)board = [[row[i] for row in board] for i in range(len(board[0]))]for lst in board: print(lst)","tags":[{"name":"算法","slug":"算法","permalink":"http://wenbo.fun/tags/算法/"}]},{"title":"Sklearn中Kmeans与可视化","date":"2017-12-13T14:02:42.000Z","path":"2017/12/13/kmeans-sklearn/","text":"KmeansK-means算法: 两个缺点: Inertia makes the assumption that clusters are convex and isotropic, which is not always the case. It responds poorly to elongated clusters, or manifolds with irregular shapes. Inertia is not a normalized metric: we just know that lower values are better and zero is optimal. But in very high-dimensional spaces, Euclidean distances tend to become inflated (this is an instance of the so-called “curse of dimensionality”). Running a dimensionality reduction algorithm such as PCA prior to k-means clustering can alleviate this problem and speed up the computations. 聚类算法：from sklearn.cluster import KMeans def init(self, n_clusters=8, init=’k-means++’, n_init=10, max_iter=300,tol=1e-4,precompute_distances=’auto’,verbose=0, random_state=None, copy_x=True, n_jobs=1): km_cluster = KMeans(n_clusters=num_clusters, max_iter=300, n_init=40,init=’k-means++’,n_jobs=-1) n_clusters : 分成的簇数也是要生成的质心数 init: 初始化质心,默认值：采用 k-means++ n_init: 设置选择质心种子次数，默认为10次。返回质心最好的一次结果（好是指计算时长短） max_ite: 每次迭代的最大次数 tol: 容忍的最小误差，当误差小于tol就会退出迭代（算法中会依赖数据本身）,默认值：le-4(0.0001) precompute_distances: 这个参数会在空间和时间之间做权衡，如果是True 会把整个距离矩阵都放到内存中，auto 会默认在数据样本大于featurs*samples 的数量大于12e6 的时候False, 默认值：“auto” verbose:是否输出详细信息,默认值：False random_state: 随机生成器的种子 ，和初始化中心有关, 默认值：None copy_x:bool 在scikit-learn 很多接口中都会有这个参数的，就是是否对输入数据继续copy 操作，以便不修改用户的输入数据。这个要理解Python 的内存机制才会比较清楚。(待研究) 默认值：True n_jobs: 使用进程的数量，与电脑的CPU有关.默认值: 1 Kmeans++ 能够解决kmeans对噪声敏感的问题。kmeans寻找种子点的时候计算该类中所有样本的平均值，如果该类中具有较为明显的离群点，会造成种子点与期望偏差过大。例如，A(1,1),B(2,2),C(3,3),D(1000,1000)，显然D点会拉动种子点向其偏移。这样，在下一轮迭代时，将大量不该属于该类的样本点错误的划入该类。为了解决这个问题，kmedoids方法采取新的种子点选取方式: 1）只从样本点中选；2）选取标准能够提高聚类效果，例如最小化J函数，或者自定义其他的代价函数。但是，kmedoids方法提高了聚类的复杂度。 k-means++算法选择初始seeds的基本思想就是：初始的聚类中心之间的相互距离要尽可能的远。 wiki上对该算法的描述如下: 从输入的数据点集合中随机选择一个点作为第一个聚类中心 对于数据集中的每一个点x，计算它与最近聚类中心(指已选择的聚类中心)的距离D(x) 选择一个新的数据点作为新的聚类中心，选择的原则是：D(x)较大的点，被选取作为聚类中心的概率较大 重复2和3直到k个聚类中心被选出来 利用这k个初始的聚类中心来运行标准的k-means算法 code import 123456from sklearn.cluster import KMeansfrom sklearn.externals import joblibimport numpy as npfrom time import timeimport matplotlib.pyplot as pltfrom sklearn.manifold import TSNE 12345678910111213141516171819// load data print('Load data...') dataSet = [] fileIn = open('./result1.txt')// result1 是一个10986x34行，一列的数据 for line in fileIn.readlines(): a = line.strip().split(' ') dataSet.append(float(a[0])) B = np.reshape(dataSet,(10986,34))// 聚类数 num_clusters = 26 km_cluster = KMeans(n_clusters=num_clusters, max_iter=300, n_init=40, \\ init='k-means++',n_jobs=-1)// 聚类label结果 result = km_cluster.fit_predict(B) print (\"Predicting result: \", result) np.savetxt(\"a.txt\",result) 降维(二向箔？)将高维的聚类数据在降到二维上显示，使用 sklearn 的 TSNE. code1： 12345678910111213141516171819202122232425262728// B 是34维 x 10986XX = B// result 是所聚的labelYY = result// 可视化def plot_embedding(X, title=None): x_min, x_max = np.min(X, 0), np.max(X, 0) X = (X - x_min) / (x_max - x_min) plt.figure() ax = plt.subplot(111) for i in range(X.shape[0]): plt.text(X[i, 0], X[i, 1], str(YY[i]), color=plt.cm.Set1(YY[i] / 10.), fontdict=&#123;'weight': 'bold', 'size': 9&#125;) plt.xticks([]), plt.yticks([]) if title is not None: plt.title(title)// t-SNE embedding of the digits datasetprint(\"Computing t-SNE embedding\")tsne = TSNE(n_components=2, init='pca', random_state=0)t0 = time()X_tsne = tsne.fit_transform(B)plot_embedding(X_tsne,\"t-SNE embedding of the digits (time %.2fs)\" % (time() - t0))// plot_embedding_3d(X_tsne,\"t-SNE embedding of the digits (time %.2fs)\" % (time() - t0))plt.show() 效果图：(分类太多看不清楚233333) code 2 :( 网路上 ) 12345678910111213141516...from sklearn.manifold import TSNEtsne = TSNE()tsne.fit_transform(data_zs) // 进行数据降维tsne = pd.DataFrame(tsne.embedding_, index = data_zs.index) //转换数据格式import matplotlib.pyplot as pltplt.rcParams['font.sans-serif'] = ['SimHei'] //用来正常显示中文标签plt.rcParams['axes.unicode_minus'] = False //用来正常显示负号//不同类别用不同颜色和样式绘图d = tsne[r[u'聚类类别'] == 0]plt.plot(d[0], d[1], 'r.')d = tsne[r[u'聚类类别'] == 1]plt.plot(d[0], d[1], 'go')d = tsne[r[u'聚类类别'] == 2]plt.plot(d[0], d[1], 'b*')plt.show()","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wenbo.fun/tags/机器学习/"},{"name":"聚类","slug":"聚类","permalink":"http://wenbo.fun/tags/聚类/"},{"name":"Kmeans","slug":"Kmeans","permalink":"http://wenbo.fun/tags/Kmeans/"}]},{"title":"keras","date":"2017-12-13T03:54:48.000Z","path":"2017/12/13/keras/","text":"Keras 中文文档","tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://wenbo.fun/tags/机器学习/"},{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://wenbo.fun/tags/Deep-Learning/"},{"name":"Keras","slug":"Keras","permalink":"http://wenbo.fun/tags/Keras/"}]},{"title":"人脸识别04：识别是不是我","date":"2017-12-10T13:12:46.000Z","path":"2017/12/10/is-my-face/","text":"代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657.........sess = tf.Session()saver.restore(sess, tf.train.latest_checkpoint('.'))def is_my_face(image): res = sess.run(predict, feed_dict=&#123;x: [image/255.0], keep_prob_5:1.0, keep_prob_75: 1.0&#125;) if res[0] == 1: return True else: return False// 使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()cam = cv2.VideoCapture(0)// Set FONT_HERSHEY_SIMPLEX// font = cv2.FONT_HERSHEY_SIMPLEXwhile True: _, img = cam.read() gray_image = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) dets = detector(gray_image, 1) if not len(dets): //print('Can`t get face.') cv2.imshow('img', img) key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0) for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 face = img[x1:y1,x2:y2] // 调整图片的尺寸 face = cv2.resize(face, (size,size)) print('Is this my face? %s' % is_my_face(face)) cv2.rectangle(img, (x2,x1),(y2,y1), (255,0,0),3) //cv2.rectangle(im, (x-22,y-90), (x+w+22, y-22), (0,255,0), -1) //cv2.putText(img, 'right', (x2,x1-40), font, 2, (255,255,255), 3) cv2.imshow('image',img) key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0)sess.close()","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"CNN","slug":"CNN","permalink":"http://wenbo.fun/tags/CNN/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://wenbo.fun/tags/TensorFlow/"}]},{"title":"人脸识别03：Tensorflow+CNN训练","date":"2017-12-08T14:05:35.000Z","path":"2017/12/08/cnn-train-faces/","text":"使用Tensorflow+CNN训练神经网络 程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import tensorflow as tfimport cv2import numpy as npimport osimport randomimport sysfrom sklearn.model_selection import train_test_splitmy_faces_path = './my_faces'other_faces_path = './other_faces'size = 64imgs = []labs = []def getPaddingSize(img): h, w, _ = img.shape top, bottom, left, right = (0,0,0,0) longest = max(h, w) if w &lt; longest: tmp = longest - w //表示整除符号 left = tmp // 2 right = tmp - left elif h &lt; longest: tmp = longest - h top = tmp // 2 bottom = tmp - top else: pass return top, bottom, left, rightdef readData(path , h=size, w=size): for filename in os.listdir(path): if filename.endswith('.jpg'): filename = path + '/' + filename img = cv2.imread(filename) top,bottom,left,right = getPaddingSize(img) // 将图片放大，,给源图像增加边界 img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=[0,0,0]) img = cv2.resize(img, (h, w)) imgs.append(img) labs.append(path)readData(my_faces_path)readData(other_faces_path)// 将图片数据与标签转换成数组imgs = np.array(imgs)labs = np.array([[0,1] if lab == my_faces_path else [1,0] for lab in labs])// 随机划分测试集与训练集 5%的测试集train_x,test_x,train_y,test_y = train_test_split(imgs, labs, test_size=0.05, random_state=random.randint(0,100))// 参数：图片数据的总数，图片的高、宽、通道// shape[0]行数train_x = train_x.reshape(train_x.shape[0], size, size, 3)test_x = test_x.reshape(test_x.shape[0], size, size, 3)// 将数据转换成小于1的数train_x = train_x.astype('float32')/255.0test_x = test_x.astype('float32')/255.0print('train size:%s, test size:%s' % (len(train_x), len(test_x)))// 图片块，每次取100张图片batch_size = 100num_batch = len(train_x) // batch_size// 保存数据 特定格式x = tf.placeholder(tf.float32, [None, size, size, 3])y_ = tf.placeholder(tf.float32, [None, 2])keep_prob_5 = tf.placeholder(tf.float32)keep_prob_75 = tf.placeholder(tf.float32)def weightVariable(shape): // 标准差 0.01 的正态分布 init = tf.random_normal(shape, stddev=0.01) return tf.Variable(init)def biasVariable(shape): init = tf.random_normal(shape) return tf.Variable(init)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1,1,1,1], padding='SAME')def maxPool(x): return tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding='SAME')def dropout(x, keep): return tf.nn.dropout(x, keep)def cnnLayer(): // 第一层 W1 = weightVariable([3,3,3,32]) // 卷积核大小(3,3)， 输入通道(3)， 输出通道(32) b1 = biasVariable([32]) // 卷积 // 作用是计算激活函数relu，即max(features, 0)。 conv1 = tf.nn.relu(conv2d(x, W1) + b1) // 池化 pool1 = maxPool(conv1) // 减少过拟合，随机让某些权重不更新 drop1 = dropout(pool1, keep_prob_5) // 第二层 W2 = weightVariable([3,3,32,64]) b2 = biasVariable([64]) conv2 = tf.nn.relu(conv2d(drop1, W2) + b2) pool2 = maxPool(conv2) drop2 = dropout(pool2, keep_prob_5) // 第三层 W3 = weightVariable([3,3,64,64]) b3 = biasVariable([64]) conv3 = tf.nn.relu(conv2d(drop2, W3) + b3) pool3 = maxPool(conv3) drop3 = dropout(pool3, keep_prob_5) // 全连接层 Wf = weightVariable([8*16*32, 512]) bf = biasVariable([512]) drop3_flat = tf.reshape(drop3, [-1, 8*16*32]) dense = tf.nn.relu(tf.matmul(drop3_flat, Wf) + bf) dropf = dropout(dense, keep_prob_75) // 输出层 Wout = weightVariable([512,2]) bout = weightVariable([2]) //out = tf.matmul(dropf, Wout) + bout out = tf.add(tf.matmul(dropf, Wout), bout) return outdef cnnTrain(): out = cnnLayer() cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=y_)) train_step = tf.train.AdamOptimizer(0.01).minimize(cross_entropy) // 比较标签是否相等，再求的所有数的平均值，tf.cast(强制转换类型) accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, 1), tf.argmax(y_, 1)), tf.float32)) // 将loss与accuracy保存以供tensorboard使用 tf.summary.scalar('loss', cross_entropy) tf.summary.scalar('accuracy', accuracy) merged_summary_op = tf.summary.merge_all() // 数据保存器的初始化 saver = tf.train.Saver() with tf.Session() as sess: sess.run(tf.global_variables_initializer()) summary_writer = tf.summary.FileWriter('./tmp', graph=tf.get_default_graph()) for n in range(10): // 每次取128(batch_size)张图片 for i in range(num_batch): batch_x = train_x[i*batch_size : (i+1)*batch_size] batch_y = train_y[i*batch_size : (i+1)*batch_size] // 开始训练数据，同时训练三个变量，返回三个数据 _,loss,summary = sess.run([train_step, cross_entropy, merged_summary_op], feed_dict=&#123;x:batch_x,y_:batch_y, keep_prob_5:0.5,keep_prob_75:0.75&#125;) summary_writer.add_summary(summary, n*num_batch+i) // 打印损失 print(n*num_batch+i, loss) if (n*num_batch+i) % 100 == 0: // 获取测试数据的准确率 acc = accuracy.eval(&#123;x:test_x, y_:test_y, keep_prob_5:1.0, keep_prob_75:1.0&#125;) print(n*num_batch+i, acc) // 准确率大于0.98时保存并退出 if acc &gt; 0.98 and n &gt; 2: saver.save(sess, './train_faces.model', global_step=n*num_batch+i) sys.exit(0) print('accuracy less 0.98, exited!')cnnTrain() 相关函数tf.nn.dropout1tf.nn.dropout(x, keep) dropout(x, keep_prob, noise_shape=None, seed=None, name=None) x: 一个Tensor。keep_prob: 一个 Python 的 float 类型。表示元素是否放电的概率。noise_shape: 一个一维的Tensor，数据类型是int32。代表元素是否独立的标志。seed: 一个Python的整数类型。设置随机种子。name: （可选）为这个操作取一个名字。 tf.nn.conv2d1return tf.nn.conv2d(x, W, strides=[1,1,1,1], padding=&apos;SAME&apos;) tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None) 除去name参数用以指定该操作的name，与方法有关的一共五个参数： 第一个参数input：指需要做卷积的输入图像，它要求是一个Tensor，具有[batch, in_height, in_width, in_channels]这样的shape，具体含义是[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个4维的Tensor，要求类型为float32和float64其中之一。 第二个参数filter：相当于CNN中的卷积核，它要求是一个Tensor，具有[filter_height, filter_width, in_channels, out_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同，有一个地方需要注意，第三维in_channels，就是参数input的第四维 第三个参数strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4 第四个参数padding：string类型的量，只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式，表示是否要保留不完全卷积的部分。 第五个参数：use_cudnn_on_gpu:bool类型，是否使用cudnn加速，默认为true 结果返回一个Tensor，这个输出，就是我们常说的feature map，shape仍然是[batch, height, width, channels]这种形式。 tf.nn.max_pool1tf.nn.max_pool(x, ksize=[1,2,2,1], strides=[1,2,2,1], padding=&apos;SAME&apos;) tf.nn.max_pool(value, ksize, strides, padding, name=None) 参数是四个，和卷积很类似：第一个参数value：需要池化的输入，一般池化层接在卷积层后面，所以输入通常是feature map，依然是[batch, height, width, channels]这样的shape第二个参数ksize：池化窗口的大小，取一个四维向量，一般是[1, height, width, 1]第三个参数strides：和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]第四个参数padding：和卷积类似，可以取’VALID’ 或者’SAME’ 返回一个Tensor，类型不变，shape仍然是[batch, height, width, channels]这种形式 train_test_splitCross Validation 基本思想是把在某种意义下将原始数据(dataset)进行分组,一部分做为训练集(train set),另一部分做为验证集(validation set or test set),首先用训练集对分类器进行训练,再利用验证集来测试训练得到的模型(model),以此来做为评价分类器的性能指标。 sklearn.model_selection.train_test_split随机划分训练集和测试集官网文档：http://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html#sklearn.model_selection.train_test_split train_test_split是交叉验证中常用的函数，功能是从样本中随机的按比例选取train data和testdata. 形式为： X_train,X_test, y_train, y_test = cross_validation.train_test_split(train_data,train_target,test_size=0.4, random_state=0) 参数解释： train_data：所要划分的样本特征集 train_target：所要划分的样本标签 test_size：样本占比，如果是整数的话就是样本的数量（0.4就是测试集占40%） random_state：是随机数的种子。 随机数种子： 其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则： 1.种子不同，产生不同的随机数 2.种子相同，即使实例不同也产生相同的随机数。","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"CNN","slug":"CNN","permalink":"http://wenbo.fun/tags/CNN/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://wenbo.fun/tags/TensorFlow/"}]},{"title":"人脸识别02：dlib批量识别其他图片集","date":"2017-12-08T13:52:15.000Z","path":"2017/12/08/set-other-people/","text":"dlib批量识别其他图片集 处理方式跟上一个程序一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import sysimport osimport cv2import dlibinput_dir = './input_img'output_dir = './other_faces'size = 64if not os.path.exists(output_dir): os.makedirs(output_dir)//使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()index = 1for (path, dirnames, filenames) in os.walk(input_dir): for filename in filenames: if filename.endswith('.jpg'): print('Being processed picture %s' % index) img_path = path+'/'+filename //从文件读取图片 img = cv2.imread(img_path) //转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) // 使用detector进行人脸检测 dets为返回的结果 dets = detector(gray_img, 1) \"\"\" 使用enumerate 函数遍历序列中的元素以及它们的下标 下标i即为人脸序号 left：人脸左边距离图片左边界的距离 ；right：人脸右边距离图片左边界的距离 top：人脸上边距离图片上边界的距离 ；bottom：人脸下边距离图片上边界的距离 \"\"\" for i, d in enumerate(dets): x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 // img[y:y+h,x:x+w] face = img[x1:y1,x2:y2] // 调整图片的尺寸 face = cv2.resize(face, (size,size)) cv2.imshow('image',face) // 保存图片 cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff if key == 27: sys.exit(0)","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"Dlib","slug":"Dlib","permalink":"http://wenbo.fun/tags/Dlib/"}]},{"title":"人脸识别01：dlib获取图片集","date":"2017-12-08T03:09:34.000Z","path":"2017/12/08/face-recognition-dlib/","text":"Dlib Dlib 是一个跨平台的C++公共库，除了线程支持，网络支持，提供测试以及大量工具等等优点，Dlib还是一个强大的机器学习的C++库，包含了许多机器学习常用的算法，而且它还不依赖其他库。 程序详解 get_my_faces_dlib.pyDlib 自带的 frontal_face_detector 特征提取器结合了现在经典的 梯度方向直方图 (Histogram of Oriented Gradients feature) Wikipedia, 参考 线性分类器 (linear classifier) Wikipedia,线性分类器与非线性分类器 图像金字塔 an image pyramid Wikipedia, 参考 滑窗检测 sliding window detection . 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import cv2import dlibimport osimport sysimport randomoutput_dir = './my_faces'size = 64if not os.path.exists(output_dir): os.makedirs(output_dir)// 改变图片的亮度与对比度def relight(img, light=1, bias=0): w = img.shape[1] h = img.shape[0] //image = [] for i in range(0,w): for j in range(0,h): for c in range(3): tmp = int(img[j,i,c]*light + bias) if tmp &gt; 255: tmp = 255 elif tmp &lt; 0: tmp = 0 img[j,i,c] = tmp return img//使用dlib自带的frontal_face_detector作为我们的特征提取器detector = dlib.get_frontal_face_detector()//打开摄像头 参数为输入流，可以为摄像头或视频文件camera = cv2.VideoCapture(0)index = 1while True: if (index &lt;= 1000): print('Being processed picture %s' % index) // 从摄像头读帧 success, img = camera.read() // 转为灰度图片 gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) // 使用detector进行人脸检测 \"\"\" The 1 in the second argument indicates that we should upsample the image 1 time. This will make everything bigger and allow us to detect more faces. \"\"\" dets = detector(gray_img, 1) print(\"Number of faces detected: &#123;&#125;\".format(len(dets))) for i, d in enumerate(dets): print(\"Detection &#123;&#125;: Left: &#123;&#125; Top: &#123;&#125; Right: &#123;&#125; Bottom: &#123;&#125;\".format( i, d.left(), d.top(), d.right(), d.bottom())) x1 = d.top() if d.top() &gt; 0 else 0 y1 = d.bottom() if d.bottom() &gt; 0 else 0 x2 = d.left() if d.left() &gt; 0 else 0 y2 = d.right() if d.right() &gt; 0 else 0 // 裁剪 face = img[x1:y1,x2:y2] // 调整图片的对比度与亮度， 对比度与亮度值都取随机数，这样能增加样本的多样性 face = relight(face, random.uniform(0.5, 1.5), random.randint(-50, 50)) face = cv2.resize(face, (size,size)) cv2.imshow('image', face) cv2.imwrite(output_dir+'/'+str(index)+'.jpg', face) index += 1 key = cv2.waitKey(30) &amp; 0xff // Esc if key == 27: break else: print('Finished!') break","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"Dlib","slug":"Dlib","permalink":"http://wenbo.fun/tags/Dlib/"}]},{"title":"人脸识别：概述","date":"2017-12-07T13:42:08.000Z","path":"2017/12/07/人脸识别1/","text":"主环境 opencv TensorFlow python3 dlib 具体搭建方式— 传送门 流程1. Get_faces 获取图片集获取所要识别的人脸的图片集最快的方法就是使用程序用摄像头拍照，要获取足够多的照片，得坐在电脑面前不停得给自己的脸摆各种姿势，这样可以提高训练后识别自己的成功率，这里先后采取了opencv和dlib自带人脸检测采集，虽然opencv识别比较快，但实际应用中会识别出一些奇怪的东西当作人脸, 所以程序采用了dlib来识别人脸。 dlib识别人脸获取图片集 2. Set_other_people 获取其他人脸图片集人脸图片集网上有很多，这里给出其中一个: 网址 下载 下载解压到项目目录下的input_img目录下,接下来使用dlib来批量识别图片中的人脸部分，并保存到指定目录other_faces下. dlib批量识别其他图片集 3. Train_faces 训练模型通过 CNN 训练数据,训练之后的数据会保存在当前目录下。 CNN 训练数据 4. Is_my_face s使用模型进行识别使用摄像头拍拍摄，在画面中标注出人脸。 进行识别","tags":[{"name":"人脸识别","slug":"人脸识别","permalink":"http://wenbo.fun/tags/人脸识别/"},{"name":"Environment","slug":"Environment","permalink":"http://wenbo.fun/tags/Environment/"}]},{"title":"Windows配置opencv3+python3+tensorflow环境","date":"2017-11-24T07:21:04.000Z","path":"2017/11/24/Win10配置opencv3+python3环境/","text":"Requirements WIN10/WIN7 64bit Anaconda3-5.0.1-Windows-x86_64 opencv_python-3.3.1+contrib-cp35-cp35m-win_amd64.whl python3.5 numpy-1.13.3+mkl-cp35-cp35m-win_amd64机器学习相关 ↓ dlib-18.17.100-cp35-none-win_amd64.whl tensorflow-1.4.0-cp35-cp35m-win_amd64.whl scikit_learn-0.19.1-cp35-cp35m-win_amd64.whl 注： 版本可以自己选择，只要注意版本号对上就行。其他额外依赖自行下载。 Anaconda概述Anaconda是一个用于科学计算的Python发行版，支持 Linux, Mac, Windows系统，提供了包管理与环境管理的功能，可以很方便地解决多版本python并存、切换以及各种第三方包安装问题。Anaconda利用工具/命令conda来进行package和environment的管理，并且已经包含了Python和相关的配套工具。 这里先解释下conda、anaconda这些概念的差别。conda可以理解为一个工具，也是一个可执行命令，其核心功能是包管理与环境管理。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，所以也称为Python的一种发行版。其实还有Miniconda，顾名思义，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。 conda的设计理念——conda将几乎所有的工具、第三方包都当做package对待，甚至包括python和conda自身！因此，conda打破了包管理与环境管理的约束，能非常方便地安装各种版本python、各种package并方便地切换。 Conda的常用操作1234567891011121314151617181920212223242526272829# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy# 如果不用-n指定环境名称，则被安装在当前活跃环境# 也可以通过-c指定通过某个channel安装# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy# 更新conda，保持conda最新conda update conda# 更新anacondaconda update anaconda# 更新pythonconda update python# 假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 创建python环境 123456789101112# 创建环境conda create -n your_env_name python=X.X（2.7、3.6等）#使用激活(或切换不同python版本)的虚拟环境,使用python --version可以检查当前python版本是否为想要的。activate your_env_name#虚拟环境中安装额外的包conda install -n your_env_name [package]#关闭虚拟环境。deactivate#删除虚拟环境conda remove -n your_env_name --all#删除环境中的某个包conda remove --name $your_env_name $package_name 配置创建一个python3.5环境安装完成后，打开Anaconda Navigator程序,创建一个新环境。 选择一个python版本，这里选择3.5.环境名称可以随便取。 鼠标左键点击进入 terminal。 进入你下载的文件夹进行pip安装numpy,注意版本要匹配。 安装opencvpip安装opencv_python。 进入python，import cv2测试，没报错一般就是成功了。 安装 dlib 和 scikit_learn同上，略。 注：dlib 建议下载最新版本。 安装 TensorFlowpip安装 tensorflow-1.4.0-cp35-cp35m-win_amd64. 测试：","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://wenbo.fun/tags/TensorFlow/"},{"name":"环境配置","slug":"环境配置","permalink":"http://wenbo.fun/tags/环境配置/"},{"name":"Opencv","slug":"Opencv","permalink":"http://wenbo.fun/tags/Opencv/"},{"name":"Python","slug":"Python","permalink":"http://wenbo.fun/tags/Python/"}]},{"title":"GIT与GITHUB的使用","date":"2017-09-22T09:59:54.000Z","path":"2017/09/22/GIT与GITHUB的使用/","text":"绑定 SSH在本地电脑安装完GIT、Hexo或jekyll，在自己GITHUB账户建立了一个yourname.github.io的respository后，我们可以绑定 ssh来更加方便地push或pull我们的代码。 获取并绑定 SSH key打开git bash，输入ssh-keygen -t rsa命令，指定 RSA算法生成密钥，回车三次，密码不用输，生成两个隐藏文件id_rsa和id_rsa.pub，一般在下面位置。 Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username.ssh 接下来就把公钥id_rsa.pub的内容拷贝到 GitHub需要的地方就可以了。如下： 验证是否成功，在Git Bash中输入ssh -T git@github.com输入yes进行测试： 如图就是成功。 用 GIT 提交代码到 Github情况1：本地没 Git 仓库直接将远程仓库clone到本地。通过clone命令创建的本地仓库，其本身就是一个 Git 仓库了，不用咱们再进行init初始化操作啦，而且自动关联远程仓库。咱们只需要在这个仓库进行修改或者添加等操作，然后commit即可。 引用于通过 Git 将代码提交到 GitHub 情况2： 本地有 Git 仓库我们新建一个仓库做演示，进入 git bash，初始化仓库。进入该“仓库”，git init初始化,然后，输入git remote add origin https://github.com/yourname/test.git命令，关联远程仓库，其中origin为远程仓库的名字(默认，可以自己取)： git pull origin master命令，同步远程仓库和本地仓库： 若第一次使用，会叫你设置邮箱和名字，按照说明做就是。 再回到本地仓库，会发现远程的README已经同步到了本地，接下来，在本地仓库新建一个名为test.txt的测试文件,输入git add和git commit命令，将文件test.txt添加并提交到本地仓库，再输入git push origin master命令，将本地仓库修改（或者添加）的内容提交到远程仓库： 最后看看是否提交成功： 更多关于Git： Git Community Book 中文版 强调：在咱们向远程仓库提交代码的时候，一定要先进行pull操作，再进行push操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是第二种提交代码的情况，很容易就出现问题。","tags":[{"name":"GIT","slug":"GIT","permalink":"http://wenbo.fun/tags/GIT/"}]}]